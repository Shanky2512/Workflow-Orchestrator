# IMPL-001: Dynamic Tool Creation & Execution Fixes

**Goal**: Transform the Agent Builder's static "Go to Connectors page" guidance into an active feature AND ensure those tools execute correctly.

---

## 1. Dynamic Tool Creation (The "Frontend" Fix)

**Problem**: User is told to manually sync tools instead of the system doing it for them.

**Resolution**: Modify `AgentDesigner._handle_tool_modification` in `apps/agent/designer/agent_designer.py`.
- **Fetch Connectors**: Retrieve valid connectors via `ConnectorManager` (internal service).
  - API: `GET /connectors/api/list` (internal: `connector_mgr.api.list()`)
  - MCP: `GET /connectors/mcp` (internal: `connector_mgr.mcp.list()`)
- **Fuzzy Match**: Check if user message matches a connector name.
  > **IMPORTANT**: Both `api.list()` and `mcp.list()` return connectors with the field `"connector_name"`, NOT `"name"`. Fuzzy match must use `connector.get("connector_name")`. See Correction #5 below.
- **Auto-Create**: If match found, call `create_tool_from_connector` and add to agent.

---

## 2. Tool Execution Logic (Deep Analysis & Fixes)

**Problem**: The current `ToolExecutor` implementation is incompatible with the tool definitions generated by `ToolRegistry` and `AgentDesigner`, specifically for API connectors.

### Analysis of `apps/tool/executor.py`
1.  **API Tools (CRITICAL BREAK)**:
    - `ToolRegistry` creates API tools with `execution_config={"connector_id": "...", "connector_source": "api"}`.
    - `ToolExecutor._execute_api` **requires** `url`, `method`, `headers` in `execution_config`.
    - **Result**: API tools created from connectors will **fail** with `ValueError: Tool ... execution_config missing 'url'`.
    - **Security Risk**: Even if we populated `url` in the registry, `ToolExecutor` would bypass the `ConnectorManager`, meaning it wouldn't handle auth token refreshing or centralized logging.

2.  **MCP Tools (Fragile)**:
    - `ToolExecutor._execute_mcp` uses a hardcoded URL: `http://localhost:8000/connectors/mcp/invoke`.
    - **Result**: This breaks if the service runs on a different port or in a containerized environment where `localhost` is ambiguous. It also adds unnecessary HTTP overhead if `ConnectorManager` is available locally in the DI container.

### Proposed Resolution
Refactor `ToolExecutor` to delegate execution to `ConnectorManager` when a `connector_id` is present.

**New Logic for `_execute_api`**:

> **CRITICAL**: `APIConnector.invoke()` is **synchronous** (verified at `echolib/services.py:2995`).
> Calling `await connector_manager.api.invoke(...)` directly will FAIL.
> MUST wrap with `asyncio.to_thread()` to avoid blocking the event loop.

```python
if "connector_id" in config:
    # MANAGED MODE: Delegate to ConnectorManager
    # api.invoke() is SYNC — wrap in thread to avoid blocking async event loop
    result = await asyncio.to_thread(
        connector_manager.api.invoke,
        config["connector_id"],
        input_data
    )
    return result
else:
    # Legacy/Manual API tool logic (Raw HTTP via httpx)
    url = config.get("url")
    if not url:
        raise ValueError(f"Tool '{tool.name}' execution_config missing 'url'")
    ...
```

**New Logic for `_execute_mcp`**:

> **CRITICAL**: The MCP connector method is `invoke_async`, NOT `invoke`.
> `MCPConnector.invoke_async()` is **async** (verified at `echolib/services.py:2171`).
> Call with `await` directly — no thread wrapping needed.
> Signature: `async def invoke_async(self, connector_id: str, payload: Optional[Dict] = None)`

```python
if "connector_id" in config:
    # MANAGED MODE: Delegate to ConnectorManager
    # mcp.invoke_async() is ASYNC — await directly, no thread wrapping
    result = await connector_manager.mcp.invoke_async(
        connector_id=config["connector_id"],
        payload=input_data
    )
    return result
else:
    # Legacy fallback (should not happen for synced tools)
    raise ValueError(f"Tool '{tool.name}' execution_config missing 'connector_id'")
```

---

## 3. Connector Field Name Mismatch Fix (ToolRegistry Sync)

**Problem**: `sync_connectors_as_tools()` in `apps/tool/registry.py` uses wrong field names when reading connector list responses.

### 3a. Connector Name Field (`registry.py:754`)

**Current code**:
```python
connector_name = connector.get("name", connector_id)
```

**Actual API response fields** (verified from `echolib/services.py`):
- `APIConnector.list()` (line 3314): returns `"connector_name"`, NOT `"name"`
- `MCPConnector.list()` (line 2257): returns raw storage dicts which also use `"connector_name"`

**Result**: Tool names always fall back to `connector_id`, producing ugly IDs like `tool_mcp_mcp_f237cb0812c3` instead of `tool_mcp_openweather_api`.

**Fix**:
```python
connector_name = connector.get("connector_name") or connector.get("name", connector_id)
```

### 3b. Description Field (`registry.py:755`)

**Current code**:
```python
connector_desc = connector.get("description", "")
```

**Actual API responses**: Neither `api.list()` nor `mcp.list()` include a top-level `"description"` field. Description lives inside `creation_payload`.

**Fix**:
```python
connector_desc = connector.get("description", "") or connector.get("creation_payload", {}).get("description", "")
```

### 3c. Same fix needed in `create_tool_from_connector` (`agent_designer.py:646`)

**Current code**:
```python
connector_name = tool_name or connector.get("name", connector_id)
```

The `connector` dict here comes from `sub_manager.get(connector_id)` which returns a dict with `"connector_name"` (verified at `services.py:2240-2255` for MCP, `services.py:3198` for API).

**Fix**:
```python
connector_name = tool_name or connector.get("connector_name") or connector.get("name", connector_id)
```

---

## 4. Technical Implementation Plan

### Step 1: Fix `ToolExecutor` (`apps/tool/executor.py`)

**1a. ConnectorManager Injection**

Add `connector_manager` as an optional constructor parameter. This is the cleanest approach — no hidden DI coupling inside methods.

```python
def __init__(self, registry: Any, default_timeout: int = 60, connector_manager: Any = None):
    self.registry = registry
    self.default_timeout = default_timeout
    self.connector_manager = connector_manager
    self._local_instances: Dict[str, Any] = {}
```

If `connector_manager` is not provided at construction time, lazy-resolve from DI as fallback:
```python
def _get_connector_manager(self):
    if self.connector_manager:
        return self.connector_manager
    try:
        from echolib.di import container
        return container.resolve('connector.manager')
    except (KeyError, ImportError):
        return None
```

**Files to update for wiring**:
- `apps/tool/container.py` — pass `ConnectorManager` instance when constructing `ToolExecutor`
- Any other location where `ToolExecutor` is instantiated

**1b. Update `_execute_api`** (line 423)

- Check `connector_id` in config **FIRST** (before `url` check)
- If `connector_id` present: `await asyncio.to_thread(cm.api.invoke, connector_id, input_data)` (SYNC method)
- If no `connector_id`: fall through to existing raw HTTP logic (legacy path)

**1c. Update `_execute_mcp`** (line 356)

- Replace hardcoded `http://localhost:8000/connectors/mcp/invoke` HTTP call
- Use `await cm.mcp.invoke_async(connector_id, payload=input_data)` (ASYNC method)
- Keep `connector_id` extraction from `config` (already correct)

### Step 2: Fix Field Name Mismatches (`apps/tool/registry.py`)

- Line 754: `connector.get("name", ...)` → `connector.get("connector_name") or connector.get("name", connector_id)`
- Line 755: `connector.get("description", "")` → add fallback to `creation_payload.description`

### Step 3: Fix Field Name in AgentDesigner (`apps/agent/designer/agent_designer.py`)

- Line 646: Same `"connector_name"` fix as Step 2
- Line 690: Same `description` fallback fix

### Step 4: Implement Dynamic Creation (`apps/agent/designer/agent_designer.py`)

- Implement `_handle_tool_modification` search & auto-create logic described in Section 1
- Use `connector.get("connector_name")` for fuzzy matching (not `"name"`)

### Step 5: Verification

- Create `scripts/verify_tool_execution.py`
- Mock `ConnectorManager` with:
  - `api.invoke(connector_id, payload)` → returns `{"success": True, "data": {...}}`
  - `mcp.invoke_async(connector_id, payload=...)` → returns `{"success": True, "output": {...}}`
- Test `ToolExecutor.invoke` with a tool definition containing `connector_id`
- Verify API path calls `asyncio.to_thread(api.invoke, ...)` (sync→thread)
- Verify MCP path calls `await mcp.invoke_async(...)` (native async)
- Verify legacy tools with `url` in config still work via raw HTTP

---

## 5. Corrections Summary

| # | Severity | Issue | Location | Fix |
|---|----------|-------|----------|-----|
| 1 | **CRITICAL** | `_execute_api` has no `connector_id` path — crashes for all connector-synced API tools | `executor.py:423` | Add `connector_id` branch with `asyncio.to_thread(cm.api.invoke, ...)` |
| 2 | **CRITICAL** | `_execute_mcp` uses hardcoded `localhost:8000` HTTP instead of `ConnectorManager` | `executor.py:396` | Replace with `await cm.mcp.invoke_async(connector_id, payload=input_data)` |
| 3 | **CRITICAL** | Original plan pseudocode: `await api.invoke()` will fail — method is sync | `dynamicTool_bug.md:38` (old) | Must use `await asyncio.to_thread(cm.api.invoke, ...)` |
| 4 | **CRITICAL** | Original plan pseudocode: `mcp.invoke()` doesn't exist on MCPConnector | `dynamicTool_bug.md:47` (old) | Method is `mcp.invoke_async(connector_id, payload=input_data)` |
| 5 | **MEDIUM** | `sync_connectors_as_tools` uses `connector.get("name")` but list APIs return `"connector_name"` | `registry.py:754` | Use `connector.get("connector_name") or connector.get("name", connector_id)` |
| 6 | **MEDIUM** | `create_tool_from_connector` same `"name"` vs `"connector_name"` mismatch | `agent_designer.py:646` | Same fix as #5 |
| 7 | **MEDIUM** | ConnectorManager injection strategy was unspecified for ToolExecutor | `executor.py:__init__` | Constructor param + lazy DI fallback; wire in `container.py` |
| 8 | **LOW** | `connector_desc` lookup misses nested `creation_payload.description` | `registry.py:755` | Fallback to `creation_payload.description` |
| 9 | **LOW** | `connector_id` check must come before `url` check in `_execute_api` | `executor.py` | Reorder: `connector_id` first, `url` second |

---

## 6. Risks

- **Circular Imports**: `ToolExecutor` needs `ConnectorManager`. Verified safe: `ConnectorManager` (`echolib/services.py`) does NOT depend on `ToolExecutor` (`apps/tool/executor.py`). Dependency is one-directional.
- **DI Availability**: `ConnectorManager` must be registered in the DI container as `'connector.manager'` before `ToolExecutor` is used. This is already the case (verified in `apps/connector/routes.py:32`).
- **Sync/Async Mismatch**: The most dangerous risk. `api.invoke()` is sync, `mcp.invoke_async()` is async. Mixing these up causes either event loop blocking (sync called without thread) or `TypeError` (async called without await). The corrected pseudocode above handles both correctly.

---

## 7. Connector API Reference (Quick Lookup)

### Verified Method Signatures (from `echolib/services.py`):

| Class | Method | Sync/Async | Line | Signature |
|-------|--------|-----------|------|-----------|
| `APIConnector` | `invoke` | **SYNC** | 2995 | `def invoke(self, connector_id: str, payload: Optional[Dict] = None) -> Dict` |
| `APIConnector` | `list` | **SYNC** | 3314 | `def list(self) -> Dict` — returns `{"success", "count", "connectors": [{connector_id, connector_name, ...}]}` |
| `APIConnector` | `get` | **SYNC** | 3198 | `def get(self, connector_id: str) -> Optional[Dict]` |
| `MCPConnector` | `invoke_async` | **ASYNC** | 2171 | `async def invoke_async(self, connector_id: str, payload: Optional[Dict] = None) -> Dict` |
| `MCPConnector` | `list` | **SYNC** | 2257 | `def list(self) -> Dict` — returns `{"success", "count", "connectors": [...]}` |
| `MCPConnector` | `get` | **SYNC** | 2240 | `def get(self, connector_id: str) -> Optional[Dict]` |
| `ConnectorManager` | `get_manager` | **SYNC** | 2003 | `def get_manager(self, connector_type: str)` — returns `.api` or `.mcp` |

### HTTP Endpoints (from `apps/connector/routes.py`):

| Endpoint | Route Method | Internal Call |
|----------|-------------|---------------|
| `GET /connectors/api/list` | `list_api_connectors` | `manager.api.list()` |
| `GET /connectors/mcp` | `list_mcp_connectors` | `manager.mcp.list()` |
| `POST /connectors/api/invoke` | `invoke_api_connector` | `manager.api.invoke(id, payload)` |
| `POST /connectors/mcp/invoke` | `invoke_mcp_connector` | `await manager.mcp.invoke_async(id, payload=payload)` |
| `GET /connectors/api/get?connector_id=` | `get_api_connector` | `manager.api.get(id)` |
| `GET /connectors/mcp/get?connector_id=` | `get_mcp_connector` | `manager.mcp.get(id)` |
