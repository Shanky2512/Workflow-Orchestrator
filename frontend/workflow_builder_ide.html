<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agentic Workflow IDE - Complete Specification v1.0</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        .canvas-grid {
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #f8f9fa;
        }

        .node {
            position: absolute;
            z-index: 10;
            cursor: grab;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border-left: 4px solid #6366f1;
            min-width: 240px;
        }

        .node:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .node-selected {
            outline: 2px solid #6366f1;
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
        }

        .port {
            width: 10px;
            height: 10px;
            background: #94a3b8;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            z-index: 20;
            cursor: crosshair;
        }

        .port:hover {
            transform: scale(1.3);
            background: #6366f1;
        }

        .port-in {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .port-out {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            background: #6366f1;
        }

        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .connection-line {
            fill: none;
            stroke: #6366f1;
            stroke-width: 3;
            opacity: 0.7;
            stroke-linecap: round;
            pointer-events: none;
        }

        .connection-line:hover {
            stroke: #ef4444;
            opacity: 1;
            stroke-width: 4;
        }

        .connection-hitarea {
            fill: none;
            stroke: transparent;
            stroke-width: 20;
            stroke-linecap: round;
            cursor: pointer;
            pointer-events: stroke;
        }

        .connection-hitarea:hover+.connection-line {
            stroke: #ef4444;
            opacity: 1;
            stroke-width: 4;
        }

        .resizer {
            width: 4px;
            background: #e5e7eb;
            cursor: col-resize;
            position: relative;
            transition: 0.2s;
            flex-shrink: 0;
        }

        .resizer:hover {
            background: #6366f1;
        }

        .resizer:active {
            background: #4f46e5;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 30;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            color: #64748b;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #f8f9fa;
            color: #6366f1;
            border-color: #6366f1;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .canvas-content {
            transform-origin: 0 0;
            transition: transform 0.2s ease-out;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .inspector-label {
            font-size: 9px;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            display: block;
        }

        .v-input {
            width: 100%;
            border: 1.5px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            outline: none;
            transition: all 0.2s;
            background: white;
        }

        .v-input:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .v-input:disabled {
            background: #f8f9fa;
            color: #94a3b8;
        }

        .tab-btn {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
        }

        .tab-btn:hover {
            color: #475569;
            background: #f8f9fa;
        }

        .tab-active {
            color: #6366f1;
            border-bottom-color: #6366f1;
            font-weight: 700;
        }

        .tool-card {
            padding: 12px;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: #f9fafb;
            transition: all 0.2s;
        }

        .tool-card:hover {
            border-color: #6366f1;
            background: white;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            min-width: 280px;
            z-index: 50;
            max-height: 400px;
            overflow-y: auto;
        }

        .dropdown-item {
            padding: 12px 16px;
            display: flex;
            align-items: start;
            gap: 12px;
            transition: all 0.2s;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .node-library-item {
            padding: 10px 12px;
            border: 1.5px solid #e5e7eb;
            border-left: 4px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .node-library-item:hover {
            border-color: #6366f1;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.12);
            transform: translateY(-1px);
        }

        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Execution Transparency Styles */
        .execution-step {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 6px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .execution-step.running {
            background: linear-gradient(90deg, #eef2ff 0%, #e0e7ff 100%);
            border-left: 3px solid #6366f1;
            animation: pulse-step 1.5s ease-in-out infinite;
        }

        .execution-step.completed {
            background: #ecfdf5;
            border-left: 3px solid #10b981;
        }

        .execution-step.failed {
            background: #fef2f2;
            border-left: 3px solid #ef4444;
        }

        @keyframes pulse-step {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .step-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .step-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #6366f1;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* A2UI step status variants */
        .execution-step.pending {
            background: #f8fafc;
            border-left: 3px solid #cbd5e1;
            color: #94a3b8;
        }

        .execution-step.interrupted {
            background: #fffbeb;
            border-left: 3px solid #f59e0b;
            animation: pulse-step 1.5s ease-in-out infinite;
        }

        .execution-step.skipped {
            background: #f8fafc;
            border-left: 3px solid #94a3b8;
            opacity: 0.6;
        }

        /* A2UI surface container */
        .a2ui-surface {
            border: 1px solid #e0e7ff;
            border-radius: 8px;
            padding: 10px;
            background: #fafbff;
            margin: 6px 0;
        }

        .a2ui-step-icon {
            font-family: 'Material Icons';
            font-size: 16px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .a2ui-step-icon.running { color: #6366f1; animation: spin 0.8s linear infinite; }
        .a2ui-step-icon.completed { color: #10b981; }
        .a2ui-step-icon.failed { color: #ef4444; }
        .a2ui-step-icon.pending { color: #94a3b8; }
        .a2ui-step-icon.interrupted { color: #f59e0b; }
        .a2ui-step-icon.skipped { color: #94a3b8; }

        .a2ui-final-output {
            margin-top: 8px;
            padding: 10px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 12px;
            color: #334155;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }

        .step-content {
            flex: 1;
        }

        .step-name {
            font-weight: 600;
            color: #334155;
        }

        .step-type {
            color: #64748b;
            font-size: 10px;
        }

        .step-output-preview {
            margin-top: 6px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            font-size: 11px;
            color: #374151;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid rgba(16, 185, 129, 0.2);
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .chat-system-message {
            background: #f1f5f9;
            border-left: 3px solid #94a3b8;
            padding: 6px 10px;
            font-size: 11px;
            color: #64748b;
            border-radius: 4px;
            margin: 4px 0;
        }

        .chat-system-message.step_started {
            background: #eef2ff;
            border-left-color: #6366f1;
        }

        .chat-system-message.step_completed {
            background: #ecfdf5;
            border-left-color: #10b981;
        }

        .chat-system-message.step_failed {
            background: #fef2f2;
            border-left-color: #ef4444;
        }

        .chat-system-message.execution_start {
            background: #fef3c7;
            border-left-color: #f59e0b;
        }

        .hitl-review-panel {
            background: linear-gradient(135deg, #eff6ff 0%, #f0f9ff 100%);
            border: 1.5px solid #93c5fd;
            border-radius: 10px;
            padding: 14px;
            margin: 8px 0;
        }

        .hitl-review-panel .hitl-title {
            font-size: 12px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .hitl-review-panel .hitl-message {
            font-size: 11px;
            color: #475569;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .hitl-review-panel .hitl-priority {
            display: inline-block;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 2px 8px;
            border-radius: 9999px;
            margin-bottom: 10px;
        }

        .hitl-priority.high,
        .hitl-priority.critical {
            background: #fef2f2;
            color: #dc2626;
        }

        .hitl-priority.medium {
            background: #fefce8;
            color: #ca8a04;
        }

        .hitl-priority.low {
            background: #f0fdf4;
            color: #16a34a;
        }

        .hitl-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .hitl-btn {
            padding: 6px 14px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.15s;
        }

        .hitl-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hitl-btn.approve {
            background: #10b981;
            color: white;
        }

        .hitl-btn.approve:hover:not(:disabled) {
            background: #059669;
        }

        .hitl-btn.reject {
            background: #ef4444;
            color: white;
        }

        .hitl-btn.reject:hover:not(:disabled) {
            background: #dc2626;
        }

        .hitl-btn.edit {
            background: #f59e0b;
            color: white;
        }

        .hitl-btn.edit:hover:not(:disabled) {
            background: #d97706;
        }

        .hitl-btn.defer {
            background: #6b7280;
            color: white;
        }

        .hitl-btn.defer:hover:not(:disabled) {
            background: #4b5563;
        }

        .hitl-edit-area {
            margin-top: 8px;
        }

        .hitl-edit-area textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 11px;
            border: 1.5px solid #cbd5e1;
            border-radius: 6px;
            resize: vertical;
            outline: none;
        }

        .hitl-edit-area textarea:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
        }

        .hitl-state-snapshot {
            margin-top: 8px;
            padding: 8px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .hitl-state-snapshot pre {
            font-size: 10px;
            color: #334155;
            white-space: pre-wrap;
            word-break: break-word;
            margin: 0;
        }

        .execution-progress-bar {
            height: 2px;
            background: #e2e8f0;
            border-radius: 1px;
            overflow: hidden;
            margin: 8px 0;
        }

        .execution-progress-bar .progress {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            animation: progress-animation 2s ease-in-out infinite;
        }

        @keyframes progress-animation {
            0% {
                width: 0%;
            }

            50% {
                width: 70%;
            }

            100% {
                width: 100%;
            }
        }
    </style>
</head>

<body class="bg-slate-50 overflow-hidden">
    <div id="app" class="h-screen flex flex-col">
        <!-- Header -->
        <header class="h-14 bg-white border-b flex items-center justify-between px-6 z-50 shadow-sm">
            <div class="flex items-center gap-3">
                <div
                    class="w-9 h-9 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-black text-lg">
                    ‚ö°</div>
                <div>
                    <h1 class="font-bold text-slate-800 text-sm">Agentic Workflow IDE</h1>
                    <span class="text-[9px] text-slate-400 font-semibold">Complete Specification v1.0</span>
                </div>
                <div class="ml-6 flex items-center gap-2">
                    <span class="text-xs text-slate-500">Workflow:</span>
                    <input type="text" v-model="workflowName" placeholder="Untitled Workflow"
                        class="px-2 py-1 text-sm border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 w-48">
                </div>
            </div>
            <div class="flex items-center gap-2">
                <button @click="clearCanvas"
                    class="px-3 py-1.5 text-xs font-semibold text-red-600 hover:bg-red-50 rounded">
                    Clear Canvas
                </button>
                <button @click="importWorkflow"
                    class="px-3 py-1.5 text-xs font-semibold text-slate-600 hover:bg-slate-50 rounded">
                    üì• Import
                </button>
                <button @click="loadWorkflowDialog"
                    class="px-3 py-1.5 text-xs font-semibold text-slate-600 hover:bg-slate-50 rounded">
                    üìÇ Load
                </button>
                <button @click="exportWorkflow"
                    class="px-3 py-1.5 text-xs font-semibold text-slate-600 hover:bg-slate-50 rounded">
                    üì§ Export
                </button>
                <button @click="saveWorkflow('draft')"
                    class="px-3 py-1.5 text-xs font-semibold text-white bg-green-600 rounded shadow-sm hover:bg-green-700">
                    üíæ Save
                </button>
                <span v-if="saveStatus" class="text-xs text-green-600 font-medium">{{ saveStatus }}</span>
                <!-- <button class="px-3 py-1.5 text-xs font-semibold text-white bg-indigo-600 rounded shadow-sm hover:bg-indigo-700">
                    ‚ñ∂ Run Workflow
                </button> -->
                <button @click="runWorkflow" :disabled="isExecuting"
                    class="px-3 py-1.5 text-xs font-semibold text-white bg-indigo-600 rounded shadow-sm hover:bg-indigo-700 disabled:bg-slate-300 disabled:cursor-not-allowed flex items-center gap-1">
                    <span v-if="!isExecuting">‚ñ∂ Run Workflow</span>
                    <span v-else class="flex items-center gap-1">
                        <span
                            class="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin"></span>
                        Running...
                    </span>
                </button>
                <input type="file" ref="fileInput" @change="handleFileImport" accept=".json" style="display: none;">
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <!-- Left Pane with Tabs (Resizable) -->
            <div :style="{width: promptPaneWidth + 'px'}" class="bg-white border-r flex flex-col overflow-hidden">

                <!-- Tab Header -->
                <div class="flex border-b">
                    <button @click="leftPaneTab = 'chat'"
                        :class="{'border-b-2 border-indigo-600 text-indigo-600 bg-indigo-50': leftPaneTab === 'chat'}"
                        class="flex-1 py-3 text-xs font-bold text-slate-500 transition">
                        üí¨ Chat
                    </button>
                    <button @click="leftPaneTab = 'nodes'"
                        :class="{'border-b-2 border-indigo-600 text-indigo-600 bg-indigo-50': leftPaneTab === 'nodes'}"
                        class="flex-1 py-3 text-xs font-bold text-slate-500 transition">
                        üî∑ Nodes
                    </button>
                    <button @click="leftPaneTab = 'agents'"
                        :class="{'border-b-2 border-indigo-600 text-indigo-600 bg-indigo-50': leftPaneTab === 'agents'}"
                        class="flex-1 py-3 text-xs font-bold text-slate-500 transition">
                        ü§ñ Agents
                    </button>
                </div>

                <!-- Chat Tab -->
                <!--
                Legacy chat tab layout (kept for reference):
                <div v-if="leftPaneTab === 'chat'" class="flex-1 flex flex-col overflow-hidden">
                    <div class="flex-1 overflow-y-auto p-4">
                        <div v-if="generatedWorkflows.length > 0" class="mb-4">
                            <div class="text-xs font-bold text-slate-700 mb-2">Generated Workflows</div>
                            <div class="space-y-2">
                                <div v-for="(workflow, idx) in generatedWorkflows" :key="idx"
                                     class="p-3 bg-slate-50 rounded-lg border hover:border-indigo-300 cursor-pointer transition">
                                    <div class="text-xs font-semibold text-slate-700 mb-1">{{ workflow.title }}</div>
                                    <div class="text-[10px] text-slate-400">{{ workflow.nodeCount }} nodes ‚Ä¢ {{ workflow.timestamp }}</div>
                                </div>
                            </div>
                        </div>
                        
                        <div v-if="isGenerating" class="p-4 bg-indigo-50 rounded-lg border-2 border-indigo-200">
                            <div class="flex items-center gap-3 mb-2">
                                <div class="w-5 h-5 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin"></div>
                                <span class="text-xs font-semibold text-indigo-600">Generating workflow...</span>
                            </div>
                            <div class="text-[10px] text-slate-500">{{ generationStatus }}</div>
                        </div>
                    </div>
                    
                    <div class="p-4 border-t bg-slate-50">
                        <textarea v-model="workflowPrompt" 
                                  @keydown.enter.meta="generateWorkflow"
                                  @keydown.enter.ctrl="generateWorkflow"
                                  placeholder="Describe your workflow...&#10;&#10;Example: Create a customer support workflow that receives Slack messages, analyzes sentiment with AI, escalates urgent issues to a human, and logs all interactions to a database."
                                  class="w-full h-32 px-3 py-2 text-xs border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                        <button @click="generateWorkflow" 
                                :disabled="!workflowPrompt.trim() || isGenerating"
                                class="w-full mt-3 py-2.5 bg-indigo-600 text-white text-xs font-bold uppercase rounded-lg hover:bg-indigo-700 disabled:bg-slate-300 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                            <span v-if="!isGenerating">‚ú® Generate Workflow</span>
                            <span v-else>Generating...</span>
                        </button>
                    </div>
                </div>
                -->
                <div v-if="leftPaneTab === 'chat'" class="flex-1 flex flex-col overflow-hidden">
                    <!-- Session History Header -->
                    <div class="px-4 pt-3 pb-2 border-b bg-slate-50">
                        <div class="flex items-center justify-between">
                            <div class="text-xs font-bold text-slate-700">üí¨ Chat with Workflow</div>
                            <div class="flex items-center gap-2">
                                <button @click="startNewSession"
                                    class="text-[10px] px-2 py-1 text-green-600 hover:bg-green-50 rounded font-medium"
                                    title="Start new chat">
                                    + New
                                </button>
                                <button
                                    @click="showSessionHistory = !showSessionHistory; if(showSessionHistory) loadSessionHistory()"
                                    class="text-[10px] px-2 py-1 text-indigo-600 hover:bg-indigo-50 rounded font-medium"
                                    title="View chat history">
                                    üìã History
                                </button>
                            </div>
                        </div>

                        <!-- Current Session Indicator -->
                        <div v-if="chatSessionId" class="mt-1 text-[9px] text-slate-400">
                            Session: {{ chatSessionId.substring(0, 8) }}...
                        </div>
                    </div>

                    <!-- Collapsible Session History Panel -->
                    <div v-if="showSessionHistory" class="border-b bg-white max-h-48 overflow-y-auto">
                        <div class="p-2">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-[10px] font-bold text-slate-500 uppercase">Recent Sessions</span>
                                <button @click="loadSessionHistory" :disabled="isLoadingSessions"
                                    class="text-[9px] text-indigo-600 hover:text-indigo-700">
                                    {{ isLoadingSessions ? 'Loading...' : '‚Üª Refresh' }}
                                </button>
                            </div>

                            <!-- Loading State -->
                            <div v-if="isLoadingSessions" class="text-center py-3">
                                <div
                                    class="w-4 h-4 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin mx-auto">
                                </div>
                            </div>

                            <!-- Error State -->
                            <div v-else-if="sessionLoadError" class="text-[10px] text-red-500 p-2 bg-red-50 rounded">
                                {{ sessionLoadError }}
                            </div>

                            <!-- Empty State -->
                            <div v-else-if="sessionHistory.length === 0"
                                class="text-[10px] text-slate-400 text-center py-3">
                                No previous sessions found
                            </div>

                            <!-- Session List -->
                            <div v-else class="space-y-1">
                                <div v-for="session in sessionHistory" :key="session.session_id"
                                    @click="resumeSession(session)"
                                    class="p-2 bg-slate-50 hover:bg-indigo-50 rounded cursor-pointer border border-transparent hover:border-indigo-200 transition-all group">
                                    <div class="flex items-start justify-between">
                                        <div class="flex-1 min-w-0">
                                            <div class="text-[11px] font-semibold text-slate-700 truncate">
                                                {{ session.title || 'Untitled Chat' }}
                                            </div>
                                            <div class="text-[9px] text-slate-400 flex items-center gap-2">
                                                <span>{{ formatSessionDate(session.last_activity || session.created_at)
                                                    }}</span>
                                                <span v-if="session.context_type === 'workflow'"
                                                    class="px-1 py-0.5 bg-indigo-100 text-indigo-600 rounded">workflow</span>
                                            </div>
                                        </div>
                                        <button @click="deleteSession(session.session_id, $event)"
                                            class="opacity-0 group-hover:opacity-100 text-red-400 hover:text-red-600 p-1 rounded hover:bg-red-50 transition-all"
                                            title="Delete session">
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-4 space-y-4">
                        <div class="mb-2">
                            <div class="space-y-2 max-h-[500px] overflow-y-auto bg-white border rounded-lg p-3">
                                <div v-if="chatMessages.length === 0" class="text-[10px] text-slate-400">
                                    No chat yet. Start the conversation below.
                                </div>
                                <!-- Execution Progress Bar (shown when executing) -->
                                <div v-if="isExecutionInProgress" class="execution-progress-bar">
                                    <div class="progress"></div>
                                </div>
                                <template v-for="(msg, idx) in chatMessages" :key="idx">
                                    <!-- User Messages -->
                                    <div v-if="msg.role === 'user'"
                                        class="bg-indigo-50 border border-indigo-100 p-2 rounded-lg">
                                        <div class="text-[10px] text-slate-400 mb-1">
                                            You ‚Ä¢ {{ msg.timestamp }}
                                        </div>
                                        <div class="text-xs whitespace-pre-wrap">{{ msg.content }}</div>
                                    </div>
                                    <!-- System Messages (Execution Steps) -->
                                    <div v-else-if="msg.role === 'system'" :class="['chat-system-message', msg.type]">
                                        <div class="flex items-center gap-2">
                                            <span v-if="msg.type === 'step_started'" class="step-spinner"></span>
                                            <span>{{ msg.content }}</span>
                                        </div>
                                        <!-- Output preview for completed steps -->
                                        <div v-if="msg.output_preview && msg.type === 'step_completed'"
                                            class="step-output-preview">
                                            ‚Üí {{ msg.output_preview }}
                                        </div>
                                    </div>
                                    <!-- HITL Review Panel -->
                                    <div v-else-if="msg.role === 'hitl_review'" class="hitl-review-panel">
                                        <div class="hitl-title">üë§ {{ msg.hitl.title || 'Human Review Required' }}</div>
                                        <div class="hitl-message">{{ msg.hitl.message || 'Please review and take action.' }}</div>
                                        <span :class="['hitl-priority', msg.hitl.priority || 'medium']">
                                            {{ msg.hitl.priority || 'medium' }} priority
                                        </span>

                                        <!-- State snapshot toggle -->
                                        <div v-if="msg.hitl.state_snapshot" style="margin-bottom: 8px;">
                                            <button @click="msg.showSnapshot = !msg.showSnapshot"
                                                class="text-[10px] text-indigo-600 hover:underline cursor-pointer bg-transparent border-none p-0">
                                                {{ msg.showSnapshot ? '‚ñº Hide' : '‚ñ∂ Show' }} agent output
                                            </button>
                                            <div v-if="msg.showSnapshot" class="hitl-state-snapshot">
                                                <pre>{{ formatHitlSnapshot(msg.hitl.state_snapshot) }}</pre>
                                            </div>
                                        </div>

                                        <!-- Edit textarea (shown when edit mode is active) -->
                                        <div v-if="hitlEditMode" class="hitl-edit-area">
                                            <textarea v-model="hitlEditContent"
                                                placeholder="Enter your edits or feedback..."></textarea>
                                        </div>

                                        <!-- Action buttons -->
                                        <div v-if="!msg.decided" class="hitl-actions">
                                            <button v-if="msg.hitl.allowed_decisions?.includes('approve')"
                                                @click="submitHitlDecision('approve', msg)" :disabled="hitlSubmitting"
                                                class="hitl-btn approve">‚úì Approve</button>
                                            <button v-if="msg.hitl.allowed_decisions?.includes('reject')"
                                                @click="submitHitlDecision('reject', msg)" :disabled="hitlSubmitting"
                                                class="hitl-btn reject">‚úó Reject</button>
                                            <button v-if="msg.hitl.allowed_decisions?.includes('edit') && !hitlEditMode"
                                                @click="hitlEditMode = true" :disabled="hitlSubmitting"
                                                class="hitl-btn edit">‚úé Edit</button>
                                            <button v-if="hitlEditMode" @click="submitHitlDecision('edit', msg)"
                                                :disabled="hitlSubmitting || !hitlEditContent.trim()"
                                                class="hitl-btn edit">Submit Edit</button>
                                            <button v-if="hitlEditMode"
                                                @click="hitlEditMode = false; hitlEditContent = ''"
                                                class="hitl-btn defer">Cancel</button>
                                            <button
                                                v-if="msg.hitl.allowed_decisions?.includes('defer') && !hitlEditMode"
                                                @click="submitHitlDecision('defer', msg)" :disabled="hitlSubmitting"
                                                class="hitl-btn defer">‚è∏ Defer</button>
                                        </div>
                                        <!-- Decision result -->
                                        <div v-else class="text-xs font-semibold mt-1" :class="{
                                                 'text-green-600': msg.decided === 'approve',
                                                 'text-red-600': msg.decided === 'reject',
                                                 'text-amber-600': msg.decided === 'edit',
                                                 'text-slate-500': msg.decided === 'defer'
                                             }">
                                            Decision: {{ msg.decided.toUpperCase() }}
                                        </div>
                                    </div>

                                    <!-- Assistant Messages -->
                                    <div v-else class="bg-slate-50 border border-slate-100 p-2 rounded-lg"
                                        :class="{'border-red-200 bg-red-50': msg.error}">
                                        <div class="text-[10px] text-slate-400 mb-1">
                                            Assistant ‚Ä¢ {{ msg.timestamp }}
                                            <span v-if="msg.execution_completed" class="text-green-600 ml-1">‚úì
                                                Completed</span>
                                        </div>
                                        <div class="text-xs whitespace-pre-wrap" :class="{'text-red-600': msg.error}">{{
                                            msg.content }}</div>
                                    </div>
                                </template>
                                <!-- Active Execution Steps Summary -->
                                <div v-if="executionSteps.length > 0 && isExecutionInProgress"
                                    class="mt-2 p-2 bg-slate-100 rounded-lg">
                                    <div class="text-[10px] font-semibold text-slate-600 mb-2">Execution Progress</div>
                                    <div v-for="step in executionSteps" :key="step.step_id"
                                        :class="['execution-step', step.status]">
                                        <div class="step-icon">
                                            <span v-if="step.status === 'running'" class="step-spinner"></span>
                                            <span v-else-if="step.status === 'completed'">‚úÖ</span>
                                            <span v-else-if="step.status === 'failed'">‚ùå</span>
                                            <span v-else>‚è≥</span>
                                        </div>
                                        <div class="step-content">
                                            <div class="step-name">{{ step.step_name }}</div>
                                            <div class="step-type">{{ step.step_type }}</div>
                                        </div>
                                    </div>
                                </div>
                                <!-- A2UI Live Execution Surface (SSE stream from App Manager) -->
                                <div v-if="a2uiActiveSurfaceId || a2uiStreamActive" class="mt-2 a2ui-surface">
                                    <div class="text-[10px] font-semibold text-indigo-600 mb-2 flex items-center gap-1">
                                        <span class="material-icons" style="font-size:13px;">smart_toy</span>
                                        {{ a2uiTitle || 'Agent Execution' }}
                                        <span v-if="a2uiStreamActive" class="ml-auto">
                                            <span class="w-3 h-3 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin inline-block"></span>
                                        </span>
                                    </div>
                                    <!-- Step List -->
                                    <div v-if="a2uiActiveSteps.length > 0" class="space-y-1">
                                        <div v-for="step in a2uiActiveSteps" :key="step.id"
                                            :class="['execution-step', step.status]">
                                            <div class="a2ui-step-icon" :class="step.status">
                                                <span class="material-icons" style="font-size:16px;">{{ step.icon || 'circle' }}</span>
                                            </div>
                                            <div class="step-content">
                                                <div class="step-name">{{ step.label }}</div>
                                                <div v-if="step.detail" class="step-type">{{ step.detail }}</div>
                                            </div>
                                            <div class="text-[9px] font-semibold ml-auto" :class="{
                                                'text-indigo-500': step.status === 'running',
                                                'text-emerald-600': step.status === 'completed',
                                                'text-red-500': step.status === 'failed',
                                                'text-amber-500': step.status === 'interrupted',
                                                'text-slate-400': step.status === 'pending' || step.status === 'skipped'
                                            }">{{ step.status }}</div>
                                        </div>
                                    </div>
                                    <!-- Final Output Card -->
                                    <div v-if="a2uiFinalOutput" class="a2ui-final-output">
                                        {{ a2uiFinalOutput }}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div v-if="generatedWorkflows.length > 0" class="mb-4">
                            <div class="text-xs font-bold text-slate-700 mb-2">Generated Workflows</div>
                            <div class="space-y-2">
                                <div v-for="(workflow, idx) in generatedWorkflows" :key="idx"
                                    class="p-3 bg-slate-50 rounded-lg border hover:border-indigo-300 cursor-pointer transition">
                                    <div class="text-xs font-semibold text-slate-700 mb-1">{{ workflow.title }}</div>
                                    <div class="text-[10px] text-slate-400">{{ workflow.nodeCount }} nodes ‚Ä¢ {{
                                        workflow.timestamp }}</div>
                                </div>
                            </div>
                        </div>

                        <div v-if="isGenerating" class="p-4 bg-indigo-50 rounded-lg border-2 border-indigo-200">
                            <div class="flex items-center gap-3 mb-2">
                                <div
                                    class="w-5 h-5 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin">
                                </div>
                                <span class="text-xs font-semibold text-indigo-600">Generating workflow...</span>
                            </div>
                            <div class="text-[10px] text-slate-500">{{ generationStatus }}</div>
                        </div>
                    </div>

                    <div class="p-4 border-t bg-slate-50 space-y-2">
                        <textarea v-model="chatInput" @keydown.enter.exact.prevent="sendChatMessage"
                            placeholder="Chat with the workflow (available even if unsaved)..."
                            class="w-full h-20 px-3 py-2 text-xs border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                        <div class="flex items-center justify-between">
                            <div class="text-[10px] text-slate-400">
                                Chat is available even for drafts; unsaved context will be sent.
                            </div>
                            <button @click="sendChatMessage" :disabled="isSendingMessage || !chatInput.trim()"
                                class="px-3 py-1.5 text-xs font-semibold text-white bg-indigo-600 rounded shadow-sm hover:bg-indigo-700 disabled:bg-slate-300 disabled:cursor-not-allowed">
                                <span v-if="!isSendingMessage">Send</span>
                                <span v-else>Sending...</span>
                            </button>
                        </div>
                    </div>

                    <div class="p-4 border-t bg-slate-50">
                        <textarea v-model="workflowPrompt" @keydown.enter.meta="generateWorkflow"
                            @keydown.enter.ctrl="generateWorkflow"
                            placeholder="Describe your workflow...&#10;&#10;Example: Create a customer support workflow that receives Slack messages, analyzes sentiment with AI, escalates urgent issues to a human, and logs all interactions to a database."
                            class="w-full h-32 px-3 py-2 text-xs border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                        <button @click="generateWorkflow" :disabled="!workflowPrompt.trim() || isGenerating"
                            class="w-full mt-3 py-2.5 bg-indigo-600 text-white text-xs font-bold uppercase rounded-lg hover:bg-indigo-700 disabled:bg-slate-300 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                            <span v-if="!isGenerating">‚ú® Generate Workflow</span>
                            <span v-else>Generating...</span>
                        </button>
                    </div>
                </div>

                <!-- Nodes Tab -->
                <div v-if="leftPaneTab === 'nodes'" class="flex-1 overflow-y-auto p-4">
                    <div class="mb-4">
                        <input type="text" v-model="searchQuery" placeholder="Search nodes..."
                            class="w-full px-3 py-2 text-xs border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    </div>

                    <div v-for="(nodes, category) in filteredLibrary" :key="category" class="mb-6">
                        <h3 class="text-[10px] font-black text-slate-400 uppercase mb-3 tracking-wider">{{ category }}
                        </h3>
                        <div class="space-y-2">
                            <div v-for="node in nodes" :key="node.type" @click="addNode(node)" class="node-library-item"
                                :style="{borderLeftColor: node.color}">
                                <div class="flex items-center gap-2">
                                    <span class="text-base">{{ node.icon }}</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="text-xs font-bold text-slate-700 truncate">{{ node.label }}</div>
                                        <div class="text-[9px] text-slate-400 truncate">{{ node.description }}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Agents Tab -->
                <div v-if="leftPaneTab === 'agents'" class="flex-1 overflow-y-auto p-4">
                    <div class="mb-4">
                        <input type="text" v-model="agentSearchQuery" placeholder="Search agents..."
                            class="w-full px-3 py-2 text-xs border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    </div>

                    <!-- My Agents (from Backend) -->
                    <div v-if="backendAgents.length > 0" class="mb-6">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-xs font-bold text-slate-700 uppercase tracking-wide">ü§ñ My Agents</h3>
                            <button @click="loadBackendAgents"
                                class="text-[10px] text-indigo-600 hover:text-indigo-700 font-medium">
                                ‚Üª Refresh
                            </button>
                        </div>
                        <div class="space-y-2">
                            <div v-for="agent in backendAgents" :key="agent.agent_id" @click="addBackendAgent(agent)"
                                class="p-3 border-2 border-l-4 rounded-lg cursor-pointer hover:border-green-500 hover:bg-green-50 transition-all bg-gradient-to-br from-green-50 to-white"
                                :style="{borderLeftColor: '#10b981'}">
                                <div class="flex items-start gap-3">
                                    <span class="text-lg">{{ agent.icon || 'ü§ñ' }}</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="text-xs font-bold text-slate-800">{{ agent.name }}</div>
                                        <div class="text-[9px] text-slate-500 mt-0.5">{{ agent.role }}</div>
                                        <div class="text-[8px] text-slate-400 mt-1 truncate">{{ agent.description }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tools Section -->
                    <div class="mb-6">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-xs font-bold text-slate-700 uppercase tracking-wide">üõ†Ô∏è Available Tools
                            </h3>
                            <div class="flex gap-2">
                                <button @click="loadRegisteredTools"
                                    class="text-[10px] text-indigo-600 hover:text-indigo-700 font-medium"
                                    title="Refresh tools list">
                                    ‚Üª Refresh
                                </button>
                                <button @click="triggerToolDiscovery" :disabled="isDiscoveringTools"
                                    class="text-[10px] text-green-600 hover:text-green-700 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Discover tools from AgentTools directory">
                                    üîç Discover
                                </button>
                            </div>
                        </div>

                        <!-- Discovery Status -->
                        <div v-if="toolDiscoveryStatus"
                            class="mb-2 p-2 bg-blue-50 border border-blue-200 rounded text-[10px] text-blue-700">
                            {{ toolDiscoveryStatus }}
                        </div>

                        <!-- Tools Load Error -->
                        <div v-if="toolsLoadError"
                            class="mb-2 p-2 bg-yellow-50 border border-yellow-200 rounded text-[10px] text-yellow-700">
                            ‚ö†Ô∏è Tools unavailable: {{ toolsLoadError }}
                        </div>

                        <!-- Registered Tools List -->
                        <div v-if="toolsLoaded && registeredTools.length > 0"
                            class="space-y-1 max-h-60 overflow-y-auto">
                            <div v-for="tool in registeredTools.slice(0, 10)" :key="tool.tool_id"
                                class="p-2 border rounded-lg hover:bg-slate-50 transition-all bg-white text-[10px]"
                                :title="tool.description">
                                <div class="flex items-start gap-2">
                                    <span class="text-xs">üîß</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="font-bold text-slate-800">{{ tool.name }}</div>
                                        <div class="text-[9px] text-slate-500 truncate">{{ tool.description || 'No description' }}</div>
                                        <div class="flex gap-1 mt-1">
                                            <span
                                                class="px-1.5 py-0.5 bg-slate-100 rounded text-[8px] text-slate-600">{{
                                                tool.tool_type }}</span>
                                            <span class="px-1.5 py-0.5 bg-green-100 rounded text-[8px] text-green-700"
                                                v-if="tool.status === 'active'">active</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div v-if="registeredTools.length > 10" class="text-center text-[10px] text-slate-500 mt-2">
                                +{{ registeredTools.length - 10 }} more tools
                            </div>
                        </div>

                        <!-- No Tools Found -->
                        <div v-else-if="toolsLoaded && registeredTools.length === 0"
                            class="p-3 bg-slate-50 border rounded-lg text-center">
                            <div class="text-slate-500 text-[10px]">No tools discovered yet</div>
                            <button @click="triggerToolDiscovery"
                                class="mt-2 text-[10px] text-green-600 hover:text-green-700 font-medium">
                                üîç Discover Tools
                            </button>
                        </div>

                        <!-- Loading State -->
                        <div v-else-if="!toolsLoaded && !toolsLoadError"
                            class="p-3 bg-slate-50 border rounded-lg text-center text-[10px] text-slate-500">
                            Loading tools...
                        </div>
                    </div>

                    <!-- Agent Templates -->
                    <div>
                        <h3 class="text-xs font-bold text-slate-700 uppercase tracking-wide mb-3">üìö Agent Templates
                        </h3>
                        <div class="space-y-3">
                            <div v-for="agent in filteredAgentTemplates" :key="agent.name"
                                @click="addAgentFromTemplate(agent)"
                                class="p-3 border-2 border-l-4 rounded-lg cursor-pointer hover:border-indigo-500 hover:bg-indigo-50 transition-all bg-gradient-to-br from-orange-50 to-white"
                                :style="{borderLeftColor: '#f59e0b'}">
                                <div class="flex items-start gap-3 mb-2">
                                    <span class="text-xl">{{ agent.icon }}</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="text-xs font-bold text-slate-800">{{ agent.name }}</div>
                                        <div class="text-[9px] text-slate-500 mt-0.5">{{ agent.description }}</div>
                                    </div>
                                </div>
                                <div class="flex flex-wrap gap-1 mt-2">
                                    <span v-for="tool in agent.tools.slice(0, 3)" :key="tool"
                                        class="text-[8px] px-2 py-0.5 bg-white rounded-full text-slate-600 font-semibold">
                                        {{ tool }}
                                    </span>
                                    <span v-if="agent.tools.length > 3"
                                        class="text-[8px] px-2 py-0.5 bg-slate-100 rounded-full text-slate-500 font-semibold">
                                        +{{ agent.tools.length - 3 }}
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Resizer -->
            <div class="resizer" @mousedown="startResize" title="Drag to resize"></div>

            <!-- Main Canvas -->
            <main class="flex-1 relative overflow-hidden">
                <div class="canvas-container">
                    <div class="canvas-content canvas-grid" :style="{ transform: `scale(${zoomLevel})` }"
                        @mousemove="handleCanvasMouseMove" @mouseup="handleCanvasMouseUp" @click="handleCanvasClick">

                        <!-- SVG Connections Layer -->
                        <svg class="connections-layer" :style="{ width: '5000px', height: '5000px' }">
                            <!-- Connections -->
                            <g v-for="conn in connections" :key="conn.id">
                                <path :d="getConnectionPath(conn)" class="connection-hitarea"
                                    @click.stop="deleteConnection(conn.id)" />
                                <path :d="getConnectionPath(conn)" class="connection-line" />
                            </g>
                        </svg>

                        <!-- Nodes -->
                        <div v-for="node in activeNodes" :key="node.id" class="node"
                            :class="{'node-selected': selected?.id === node.id}" :style="{ 
                                 left: node.x+'px', 
                                 top: node.y+'px', 
                                 borderLeftColor: node.color 
                             }" @mousedown="startDrag(node, $event)" @click.stop="selectNode(node)">

                            <div class="p-3">
                                <div class="flex justify-between items-start mb-2">
                                    <div class="flex-1 min-w-0">
                                        <div class="text-[9px] font-black uppercase text-slate-400 mb-0.5">{{ node.type
                                            }}</div>
                                        <div class="text-xs font-bold text-slate-800 truncate">{{ node.name }}</div>
                                    </div>
                                    <span class="text-lg ml-2">{{ node.icon }}</span>
                                </div>

                                <!-- Node Status Badge -->
                                <div v-if="node.status" class="mt-2">
                                    <span class="badge" :class="{
                                              'bg-green-100 text-green-700': node.status === 'success',
                                              'bg-blue-100 text-blue-700': node.status === 'running',
                                              'bg-red-100 text-red-700': node.status === 'failed',
                                              'bg-slate-100 text-slate-600': node.status === 'idle'
                                          }">
                                        {{ node.status }}
                                    </span>
                                </div>
                            </div>

                            <div class="port port-in" @mousedown.stop="link(node, 'in')"></div>
                            <div class="port port-out" @mousedown.stop="link(node, 'out')"></div>
                        </div>

                        <!-- Empty State -->
                        <div v-if="activeNodes.length === 0"
                            class="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <div class="text-center">
                                <div class="text-6xl mb-4 opacity-10">üé®</div>
                                <h3 class="text-sm font-bold text-slate-400 mb-2">Start Building Your Workflow</h3>
                                <p class="text-xs text-slate-300">Use AI Chat or drag nodes from the left panel</p>
                            </div>
                        </div>
                    </div>

                    <!-- Zoom Controls -->
                    <div class="zoom-controls">
                        <button @click="zoomIn" class="zoom-btn">+</button>
                        <div class="zoom-btn text-xs" style="cursor: default;">{{ Math.round(zoomLevel * 100) }}%</div>
                        <button @click="zoomOut" class="zoom-btn">‚àí</button>
                        <button @click="resetZoom" class="zoom-btn text-sm">‚ü≤</button>
                    </div>
                </div>
            </main>

            <!-- Right Inspector Panel -->
            <aside v-if="selected" class="w-[420px] bg-white border-l shadow-xl flex flex-col overflow-hidden">
                <!-- Inspector Header -->
                <div class="p-4 border-b bg-slate-50 flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 bg-white rounded-lg shadow-sm flex items-center justify-center text-xl">
                            {{ selected.icon }}
                        </div>
                        <div class="flex-1 min-w-0">
                            <input v-model="selected.name"
                                class="font-bold text-sm bg-transparent outline-none text-indigo-600 w-full"
                                placeholder="Node name...">
                            <span class="text-[9px] text-slate-400 uppercase font-bold">{{ selected.type }} Node</span>
                        </div>
                    </div>
                    <button @click="selected = null"
                        class="text-slate-400 hover:text-slate-600 font-bold text-xl w-8 h-8 flex items-center justify-center rounded hover:bg-slate-100">
                        √ó
                    </button>
                </div>

                <!-- Open Definition Button -->
                <div class="px-4 py-3 border-b bg-white">
                    <button
                        class="w-full py-2 border border-slate-200 rounded-lg text-xs font-semibold text-slate-600 hover:bg-slate-50 flex items-center justify-center gap-2">
                        <span>&lt;/&gt;</span>
                        Open Definition
                    </button>
                </div>

                <!-- Tabs (for Agent, Prompt, Subagent) -->
                <div v-if="['Agent', 'Prompt', 'Subagent'].includes(selected.type)" class="flex border-b bg-white">
                    <button @click="activeTab = 'overview'" :class="{'tab-active': activeTab === 'overview'}"
                        class="tab-btn flex-1">
                        Overview
                    </button>
                    <button @click="activeTab = 'routing'" :class="{'tab-active': activeTab === 'routing'}"
                        class="tab-btn flex-1">
                        Routing
                    </button>
                    <button @click="activeTab = 'settings'" :class="{'tab-active': activeTab === 'settings'}"
                        class="tab-btn flex-1">
                        Settings
                    </button>
                </div>

                <!-- Inspector Content -->
                <div class="flex-1 overflow-y-auto scrollbar-thin">
                    <div class="p-6 space-y-6">

                        <!-- START NODE -->
                        <template v-if="selected.type === 'Start'">
                            <section>
                                <label class="inspector-label">Input Variables</label>
                                <div class="space-y-3">
                                    <div v-for="(v, i) in selected.config.inputVariables" :key="i"
                                        class="p-3 border rounded-lg bg-slate-50 relative">
                                        <div class="grid grid-cols-2 gap-2 mb-2">
                                            <input v-model="v.name" placeholder="Variable name" class="v-input text-xs">
                                            <select v-model="v.type" class="v-input text-xs">
                                                <option>string</option>
                                                <option>number</option>
                                                <option>boolean</option>
                                                <option>object</option>
                                                <option>array</option>
                                            </select>
                                        </div>
                                        <input v-model="v.description" placeholder="Description (optional)"
                                            class="v-input text-xs">
                                        <label class="flex items-center gap-2 mt-2">
                                            <input type="checkbox" v-model="v.required" class="rounded">
                                            <span class="text-xs text-slate-600">Required</span>
                                        </label>
                                        <button @click="selected.config.inputVariables.splice(i, 1)"
                                            class="absolute -top-2 -right-2 w-6 h-6 bg-white border rounded-full text-xs shadow hover:bg-red-50 hover:text-red-600">
                                            √ó
                                        </button>
                                    </div>
                                    <button @click="addInputVariable"
                                        class="w-full py-2 border-2 border-dashed border-slate-200 rounded-lg text-xs font-bold text-slate-400 hover:bg-slate-50 hover:border-indigo-300">
                                        + Add Variable
                                    </button>
                                </div>
                            </section>
                        </template>

                        <!-- END NODE -->
                        <template v-if="selected.type === 'End'">
                            <section>
                                <label class="inspector-label">Output Variables</label>
                                <div class="space-y-3">
                                    <div v-for="(v, i) in selected.config.outputVariables" :key="i"
                                        class="p-3 border rounded-lg bg-slate-50 relative">
                                        <input v-model="v.name" placeholder="Output name" class="v-input text-xs mb-2">
                                        <select v-model="v.type" class="v-input text-xs">
                                            <option>string</option>
                                            <option>number</option>
                                            <option>boolean</option>
                                            <option>object</option>
                                        </select>
                                        <button @click="selected.config.outputVariables.splice(i, 1)"
                                            class="absolute -top-2 -right-2 w-6 h-6 bg-white border rounded-full text-xs shadow hover:bg-red-50 hover:text-red-600">
                                            √ó
                                        </button>
                                    </div>
                                    <button @click="addOutputVariable"
                                        class="w-full py-2 border-2 border-dashed rounded-lg text-xs font-bold text-slate-400 hover:bg-slate-50">
                                        + Add Output
                                    </button>
                                </div>
                            </section>
                        </template>

                        <!-- AGENT NODE -->
                        <template v-if="selected.type === 'Agent'">
                            <!-- Overview Tab -->
                            <template v-if="activeTab === 'overview'">
                                <!-- Agent Identity -->
                                <section>
                                    <label class="inspector-label">Agent Name / Role</label>
                                    <input v-model="selected.name" class="v-input font-semibold"
                                        placeholder="e.g., Research Agent, Customer Support">
                                </section>

                                <!-- Model Selection -->
                                <section>
                                    <label class="inspector-label">Model</label>
                                    <select v-model="selected.config.model.modelName"
                                        class="v-input text-sm font-semibold" @change="updateModelDisplay">
                                        <option value="openrouter-model">Open Router</option>
                                        <option value="claude-sonnet-4-5-20250514">Claude Sonnet 4.5</option>
                                        <option value="claude-opus-4-20250514">Claude Opus 4</option>
                                        <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5</option>
                                        <option value="gpt-4-turbo">GPT-4 Turbo</option>
                                        <option value="gpt-4o">GPT-4o</option>
                                        <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                        <option value="gemini-pro">Gemini Pro</option>
                                        <option value="gemini-ultra">Gemini Ultra</option>
                                    </select>
                                </section>

                                <!-- Prompt -->
                                <section>
                                    <div class="flex items-center justify-between mb-2">
                                        <label class="inspector-label">System Prompt</label>
                                    </div>
                                    <textarea v-model="selected.config.prompt" class="v-input h-32 font-mono text-xs"
                                        placeholder="You are a helpful assistant..."></textarea>
                                </section>

                                <!-- Tools Section (only for Agent type) -->
                                <section v-if="selected.type === 'Agent'">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center gap-2">
                                            <label class="inspector-label mb-0">TOOLS</label>
                                            <button class="text-xs text-slate-400 hover:text-slate-600">‚ÑπÔ∏è</button>
                                        </div>
                                        <div class="relative">
                                            <button @click="showToolDropdown = !showToolDropdown"
                                                class="px-3 py-1.5 bg-indigo-600 text-white text-xs font-semibold rounded-lg shadow-sm hover:bg-indigo-700 flex items-center gap-1">
                                                + Tool
                                                <span class="text-[10px]">‚ñº</span>
                                            </button>

                                            <!-- Tool Type Dropdown -->
                                            <div v-if="showToolDropdown" class="dropdown-menu max-h-80 overflow-y-auto">
                                                <!-- Built-in Tool Types -->
                                                <div class="p-2 border-b bg-slate-50">
                                                    <div class="text-[10px] font-bold text-slate-400 uppercase">Tool
                                                        Type</div>
                                                </div>
                                                <div @click="addBuiltinTool('code')" class="dropdown-item">
                                                    <span class="text-lg">üíª</span>
                                                    <div class="flex-1">
                                                        <div class="text-xs font-bold text-slate-800">Code</div>
                                                        <div class="text-[10px] text-slate-400">Run custom code</div>
                                                    </div>
                                                </div>
                                                <div @click="addBuiltinTool('subworkflow')" class="dropdown-item">
                                                    <span class="text-lg">üîÄ</span>
                                                    <div class="flex-1">
                                                        <div class="text-xs font-bold text-slate-800">Subworkflow</div>
                                                        <div class="text-[10px] text-slate-400">Execute a sub-workflow
                                                        </div>
                                                    </div>
                                                </div>
                                                <div @click="addBuiltinTool('subworkflow_deployment')"
                                                    class="dropdown-item">
                                                    <span class="text-lg">üí†</span>
                                                    <div class="flex-1">
                                                        <div class="text-xs font-bold text-slate-800">Subworkflow
                                                            Deployment</div>
                                                        <div class="text-[10px] text-slate-400">Execute deployed
                                                            sub-workflow</div>
                                                    </div>
                                                </div>
                                                <div @click="addBuiltinTool('mcp_server')" class="dropdown-item">
                                                    <span class="text-lg">üîå</span>
                                                    <div class="flex-1">
                                                        <div class="text-xs font-bold text-slate-800">MCP Server</div>
                                                        <div class="text-[10px] text-slate-400">Connect to MCP servers
                                                        </div>
                                                    </div>
                                                </div>

                                                <!-- Registered Tools from Backend (filtered to exclude already-added tools) -->
                                                <div v-if="toolsLoaded && availableTools.length > 0"
                                                    class="p-2 border-b border-t bg-green-50 mt-1">
                                                    <div class="text-[10px] font-bold text-green-600 uppercase">
                                                        Available Tools</div>
                                                </div>
                                                <div v-for="tool in availableTools" :key="tool.tool_id"
                                                    @click="addTool(tool)" class="dropdown-item">
                                                    <span class="text-lg">{{ getToolIcon(tool.tool_type) }}</span>
                                                    <div class="flex-1 min-w-0">
                                                        <div class="text-xs font-bold text-slate-800">{{ tool.name }}
                                                        </div>
                                                        <div class="text-[10px] text-slate-400 truncate max-w-[180px]">
                                                            {{ tool.description?.slice(0, 40) }}...</div>
                                                    </div>
                                                    <span
                                                        class="text-[9px] px-1 py-0.5 bg-green-100 text-green-700 rounded">{{
                                                        tool.tool_type }}</span>
                                                </div>
                                                <!-- Message when all tools are already added -->
                                                <div v-if="toolsLoaded && registeredTools.length > 0 && availableTools.length === 0"
                                                    class="p-3 text-center text-slate-500 text-xs">
                                                    <div class="text-lg mb-1">‚úÖ</div>
                                                    All registered tools have been added
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Tools List -->
                                    <div class="space-y-2">
                                        <div v-for="(tool, idx) in selected.config.tools" :key="idx"
                                            class="tool-card cursor-pointer" @click="openToolConfig(idx)">
                                            <span class="text-lg">{{ getToolIcon(tool.type) }}</span>
                                            <div class="flex-1 min-w-0">
                                                <div class="text-xs font-bold text-slate-800 truncate">{{ tool.name }}
                                                </div>
                                                <div class="text-[10px] text-slate-400 truncate">{{ tool.type }}</div>
                                            </div>
                                            <button @click.stop="removeTool(idx)"
                                                class="text-slate-400 hover:text-red-600 text-sm">
                                                √ó
                                            </button>
                                        </div>
                                        <div v-if="selected.config.tools.length === 0"
                                            class="p-6 text-center border-2 border-dashed rounded-lg">
                                            <div class="text-2xl mb-2 opacity-20">üîß</div>
                                            <div class="text-xs text-slate-400">No tools added yet</div>
                                        </div>
                                    </div>
                                </section>

                                <!-- Max Iterations -->
                                <section>
                                    <label class="inspector-label flex items-center gap-2">
                                        Max Prompt Iterations
                                        <button class="text-xs text-slate-400 hover:text-slate-600">‚ÑπÔ∏è</button>
                                    </label>
                                    <div class="flex items-center gap-3">
                                        <input v-model.number="selected.config.maxIterations" type="number" min="1"
                                            max="50" class="v-input flex-1 text-center font-bold text-lg">
                                        <div class="flex flex-col gap-1">
                                            <button @click="selected.config.maxIterations++"
                                                class="w-8 h-6 bg-slate-100 rounded text-xs hover:bg-slate-200">
                                                +
                                            </button>
                                            <button
                                                @click="selected.config.maxIterations = Math.max(1, selected.config.maxIterations - 1)"
                                                class="w-8 h-6 bg-slate-100 rounded text-xs hover:bg-slate-200">
                                                ‚àí
                                            </button>
                                        </div>
                                    </div>
                                </section>

                                <!-- Agent Variables -->
                                <section>
                                    <div class="flex items-center justify-between mb-3">
                                        <label class="inspector-label mb-0">Agent Variables</label>
                                        <button @click="addAgentVariable"
                                            class="text-xs text-indigo-600 font-semibold hover:underline">
                                            + Add Variable
                                        </button>
                                    </div>
                                    <div class="space-y-2">
                                        <div v-for="(variable, idx) in (selected.config.variables || [])" :key="idx"
                                            class="p-3 border rounded-lg bg-slate-50 relative">
                                            <div class="grid grid-cols-2 gap-2 mb-2">
                                                <input v-model="variable.name" placeholder="Variable name"
                                                    class="v-input text-xs">
                                                <select v-model="variable.type" class="v-input text-xs">
                                                    <option value="string">String</option>
                                                    <option value="number">Number</option>
                                                    <option value="boolean">Boolean</option>
                                                    <option value="object">Object</option>
                                                    <option value="array">Array</option>
                                                </select>
                                            </div>
                                            <input v-model="variable.defaultValue"
                                                placeholder="Default value (optional)" class="v-input text-xs">
                                            <button @click="selected.config.variables.splice(idx, 1)"
                                                class="absolute -top-2 -right-2 w-6 h-6 bg-white border rounded-full text-xs shadow hover:bg-red-50 hover:text-red-600">
                                                √ó
                                            </button>
                                        </div>
                                        <div v-if="!selected.config.variables || selected.config.variables.length === 0"
                                            class="p-4 text-center border-2 border-dashed rounded-lg">
                                            <div class="text-xs text-slate-400">No variables defined</div>
                                        </div>
                                    </div>
                                </section>

                                <!-- Connected Agents -->
                                <section>
                                    <label class="inspector-label">Connected Agents (A2A)</label>
                                    <div class="space-y-2">
                                        <div v-for="agent in getConnectedAgents(selected.id)" :key="agent.id"
                                            class="p-3 border rounded-lg bg-gradient-to-br from-blue-50 to-white flex items-center gap-3">
                                            <span class="text-lg">{{ agent.icon }}</span>
                                            <div class="flex-1 min-w-0">
                                                <div class="text-xs font-bold text-slate-800 truncate">{{ agent.name }}
                                                </div>
                                                <div class="text-[10px] text-slate-400">{{ agent.type }}</div>
                                            </div>
                                            <span class="text-[10px] text-blue-600 font-semibold">‚Üí</span>
                                        </div>
                                        <div v-if="getConnectedAgents(selected.id).length === 0"
                                            class="p-4 text-center border-2 border-dashed rounded-lg">
                                            <div class="text-xs text-slate-400">No connected agents</div>
                                            <div class="text-[10px] text-slate-300 mt-1">Connect nodes to enable A2A
                                                collaboration</div>
                                        </div>
                                    </div>
                                </section>
                            </template>

                            <!-- Routing Tab -->
                            <template v-if="activeTab === 'routing'">
                                <section>
                                    <label class="inspector-label">Routing Strategy</label>
                                    <select v-model="selected.config.routing.strategy" class="v-input">
                                        <option value="llm-driven">LLM-Driven</option>
                                        <option value="rule-based">Rule-Based</option>
                                        <option value="manual">Manual</option>
                                    </select>
                                </section>

                                <section>
                                    <label class="inspector-label">Conditional Routes</label>
                                    <div class="space-y-3">
                                        <div v-for="(route, i) in selected.config.routing.routes" :key="i"
                                            class="p-3 border rounded-lg bg-blue-50/30">
                                            <div class="text-[10px] font-bold text-blue-600 uppercase mb-2">Route #{{ i
                                                + 1 }}</div>
                                            <textarea v-model="route.condition" placeholder="condition expression"
                                                class="v-input h-16 mb-2 text-xs font-mono"></textarea>
                                            <input v-model="route.targetNodeId" placeholder="Target node ID"
                                                class="v-input text-xs">
                                        </div>
                                        <button @click="addRoute"
                                            class="w-full py-2 border-2 border-dashed rounded-lg text-xs font-bold text-slate-400 hover:bg-slate-50">
                                            + Add Route
                                        </button>
                                    </div>
                                </section>
                            </template>

                            <!-- Settings Tab -->
                            <template v-if="activeTab === 'settings'">
                                <section>
                                    <label class="inspector-label">Temperature</label>
                                    <input v-model.number="selected.config.temperature" type="range" min="0" max="1"
                                        step="0.1" class="w-full">
                                    <div class="flex justify-between text-xs text-slate-400 mt-1">
                                        <span>Precise</span>
                                        <span class="font-bold text-indigo-600">{{ selected.config.temperature }}</span>
                                        <span>Creative</span>
                                    </div>
                                </section>

                                <section>
                                    <label class="inspector-label">Top P</label>
                                    <input v-model.number="selected.config.topP" type="range" min="0" max="1"
                                        step="0.05" class="w-full">
                                    <div class="flex justify-between text-xs text-slate-400 mt-1">
                                        <span>Focused</span>
                                        <span class="font-bold text-indigo-600">{{ selected.config.topP !== undefined ?
                                            selected.config.topP : 0.9 }}</span>
                                        <span>Diverse</span>
                                    </div>
                                </section>

                                <section>
                                    <label class="inspector-label">Max Tokens</label>
                                    <input v-model.number="selected.config.maxTokens" type="number" class="v-input">
                                </section>

                                <section>
                                    <label class="inspector-label">Memory</label>
                                    <label class="flex items-center gap-2 mb-2">
                                        <input type="checkbox" v-model="selected.config.memory.enabled" class="rounded">
                                        <span class="text-xs font-semibold text-slate-700">Enable Memory</span>
                                    </label>
                                    <select v-model="selected.config.memory.type"
                                        :disabled="!selected.config.memory.enabled" class="v-input">
                                        <option value="short-term">Short-term</option>
                                        <option value="long-term">Long-term</option>
                                        <option value="both">Both</option>
                                    </select>
                                </section>

                                <!-- Adornments Section -->
                                <section>
                                    <div class="flex items-center justify-between mb-3">
                                        <label class="inspector-label mb-0">Adornments (Try & Retry)</label>
                                        <button @click="addAdornment"
                                            class="text-xs text-indigo-600 font-semibold hover:underline">
                                            + Add Adornment
                                        </button>
                                    </div>
                                    <div class="space-y-3">
                                        <div v-for="(adornment, idx) in (selected.config.adornments || [])" :key="idx"
                                            class="p-4 border-2 rounded-lg bg-gradient-to-br from-purple-50 to-white relative">
                                            <div class="absolute -top-2 -right-2 flex gap-1">
                                                <button @click="selected.config.adornments.splice(idx, 1)"
                                                    class="w-6 h-6 bg-white border rounded-full text-xs shadow hover:bg-red-50 hover:text-red-600">
                                                    √ó
                                                </button>
                                            </div>

                                            <div class="text-[10px] font-bold text-purple-600 uppercase mb-3">
                                                Adornment #{{ idx + 1 }}
                                            </div>

                                            <div class="space-y-3">
                                                <div>
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">Type</label>
                                                    <select v-model="adornment.type" class="v-input text-xs">
                                                        <option value="try">Try</option>
                                                        <option value="retry">Retry</option>
                                                        <option value="try-catch">Try-Catch</option>
                                                        <option value="fallback">Fallback</option>
                                                    </select>
                                                </div>

                                                <div v-if="['retry', 'try-catch'].includes(adornment.type)">
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">Max
                                                        Attempts</label>
                                                    <input v-model.number="adornment.maxAttempts" type="number" min="1"
                                                        max="10" class="v-input text-xs">
                                                </div>

                                                <div v-if="['retry', 'try-catch'].includes(adornment.type)">
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">Backoff
                                                        Strategy</label>
                                                    <select v-model="adornment.backoffStrategy" class="v-input text-xs">
                                                        <option value="exponential">Exponential</option>
                                                        <option value="linear">Linear</option>
                                                        <option value="fixed">Fixed</option>
                                                    </select>
                                                </div>

                                                <div v-if="adornment.backoffStrategy">
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">
                                                        {{ adornment.backoffStrategy === 'exponential' ? 'Base Delay (ms)' : 'Delay (ms)' }}
                                                    </label>
                                                    <input v-model.number="adornment.delay" type="number"
                                                        class="v-input text-xs" placeholder="1000">
                                                </div>

                                                <div v-if="adornment.type === 'fallback'">
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">Fallback
                                                        Action</label>
                                                    <select v-model="adornment.fallbackAction" class="v-input text-xs">
                                                        <option value="default_value">Use Default Value</option>
                                                        <option value="cached_result">Use Cached Result</option>
                                                        <option value="alternative_node">Alternative Node</option>
                                                    </select>
                                                </div>

                                                <div v-if="adornment.type === 'try-catch'">
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">On
                                                        Error</label>
                                                    <select v-model="adornment.onError" class="v-input text-xs">
                                                        <option value="continue">Continue</option>
                                                        <option value="stop">Stop Workflow</option>
                                                        <option value="notify">Notify & Continue</option>
                                                    </select>
                                                </div>

                                                <div>
                                                    <label
                                                        class="text-[10px] font-bold text-slate-500 uppercase mb-1 block">Timeout
                                                        (seconds)</label>
                                                    <input v-model.number="adornment.timeout" type="number"
                                                        class="v-input text-xs" placeholder="30">
                                                </div>

                                                <div>
                                                    <label class="flex items-center gap-2">
                                                        <input type="checkbox" v-model="adornment.enabled"
                                                            class="rounded">
                                                        <span
                                                            class="text-xs font-semibold text-slate-700">Enabled</span>
                                                    </label>
                                                </div>
                                            </div>
                                        </div>

                                        <div v-if="!selected.config.adornments || selected.config.adornments.length === 0"
                                            class="p-6 text-center border-2 border-dashed rounded-lg">
                                            <div class="text-2xl mb-2 opacity-20">üîÑ</div>
                                            <div class="text-xs text-slate-400">No adornments configured</div>
                                            <div class="text-[10px] text-slate-300 mt-1">Add retry logic, error
                                                handling, and fallback strategies</div>
                                        </div>
                                    </div>
                                </section>
                            </template>
                        </template>

                        <!-- CONDITIONAL NODE -->
                        <template v-if="selected.type === 'Conditional'">
                            <section>
                                <label class="inspector-label">Branches</label>
                                <div class="space-y-3">
                                    <div v-for="(branch, i) in selected.config.branches" :key="i"
                                        class="p-3 border rounded-lg"
                                        :class="i === 0 ? 'bg-purple-50/30' : i === selected.config.branches.length - 1 ? 'bg-slate-50' : 'bg-blue-50/30'">
                                        <div class="flex justify-between mb-2">
                                            <span class="text-[10px] font-bold uppercase"
                                                :class="i === 0 ? 'text-purple-600' : i === selected.config.branches.length - 1 ? 'text-slate-500' : 'text-blue-600'">
                                                {{ i === 0 ? 'IF' : i === selected.config.branches.length - 1 ? 'ELSE' :
                                                'ELIF' }}
                                            </span>
                                            <button v-if="i > 0" @click="selected.config.branches.splice(i, 1)"
                                                class="text-xs text-red-600 hover:underline">Remove</button>
                                        </div>
                                        <textarea v-if="i < selected.config.branches.length - 1"
                                            v-model="branch.condition" placeholder="e.g., score > 80"
                                            class="v-input h-16 mb-2 text-xs font-mono"></textarea>
                                        <input v-model="branch.targetNodeId" placeholder="Target node (optional)"
                                            class="v-input text-xs">
                                    </div>
                                    <button @click="addBranch"
                                        class="w-full py-2 border-2 border-dashed rounded-lg text-xs font-bold text-slate-400 hover:bg-slate-50">
                                        + Add Branch (ELIF)
                                    </button>
                                </div>
                            </section>
                        </template>

                        <!-- API NODE -->
                        <template v-if="selected.type === 'API'">
                            <section>
                                <label class="inspector-label">Request Configuration</label>
                                <div class="flex gap-2 mb-3">
                                    <select v-model="selected.config.method"
                                        class="v-input w-24 font-bold text-indigo-600">
                                        <option>GET</option>
                                        <option>POST</option>
                                        <option>PUT</option>
                                        <option>DELETE</option>
                                        <option>PATCH</option>
                                    </select>
                                    <input v-model="selected.config.url" placeholder="https://api.example.com/endpoint"
                                        class="v-input flex-1 font-mono text-xs">
                                </div>
                            </section>

                            <section>
                                <label class="inspector-label">Headers</label>
                                <div
                                    class="p-3 border rounded-lg bg-slate-900 text-xs font-mono text-green-400 overflow-x-auto">
                                    {{ JSON.stringify(selected.config.headers || {}, null, 2) }}
                                </div>
                            </section>

                            <section>
                                <label class="inspector-label">Authentication</label>
                                <select v-model="selected.config.auth.type" class="v-input mb-2">
                                    <option value="none">None</option>
                                    <option value="api_key">API Key</option>
                                    <option value="bearer">Bearer Token</option>
                                    <option value="basic">Basic Auth</option>
                                </select>

                                <!-- Basic Auth: separate username + password -->
                                <template v-if="selected.config.auth.type === 'basic'">
                                    <input v-model="selected.config.auth.username" placeholder="Username"
                                        class="v-input mb-1">
                                    <input v-model="selected.config.auth.password" type="password"
                                        placeholder="Password" class="v-input">
                                </template>

                                <!-- Bearer Token -->
                                <template v-if="selected.config.auth.type === 'bearer'">
                                    <input v-model="selected.config.auth.token" type="password"
                                        placeholder="Bearer Token" class="v-input">
                                </template>

                                <!-- API Key: param name + key value + location -->
                                <template v-if="selected.config.auth.type === 'api_key'">
                                    <input v-model="selected.config.auth.param_name"
                                        placeholder="Header/Param name (e.g. X-API-Key)" class="v-input mb-1">
                                    <input v-model="selected.config.auth.key" type="password"
                                        placeholder="API Key Value" class="v-input mb-1">
                                    <select v-model="selected.config.auth.location" class="v-input">
                                        <option value="header">Header</option>
                                        <option value="query">Query Parameter</option>
                                    </select>
                                </template>
                            </section>
                        </template>

                        <!-- HITL NODE -->
                        <template v-if="selected.type === 'HITL'">
                            <section>
                                <label class="inspector-label">Review Request</label>
                                <input v-model="selected.config.title" placeholder="Review title" class="v-input mb-2">
                                <textarea v-model="selected.config.message" placeholder="Message to reviewer..."
                                    class="v-input h-24"></textarea>
                            </section>

                            <section>
                                <label class="inspector-label">Priority</label>
                                <select v-model="selected.config.priority" class="v-input">
                                    <option value="low">Low</option>
                                    <option value="medium">Medium</option>
                                    <option value="high">High</option>
                                    <option value="critical">Critical</option>
                                </select>
                            </section>

                            <section>
                                <label class="inspector-label">Allowed Decisions</label>
                                <div class="space-y-2">
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" checked disabled class="rounded">
                                        <span class="text-xs">Approve</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" checked disabled class="rounded">
                                        <span class="text-xs">Reject</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" v-model="selected.config.allowEdit" class="rounded">
                                        <span class="text-xs">Edit</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" v-model="selected.config.allowDefer" class="rounded">
                                        <span class="text-xs">Defer</span>
                                    </label>
                                </div>
                            </section>
                        </template>

                        <!-- SELF-REVIEW NODE -->
                        <template v-if="selected.type === 'Self-Review'">
                            <section>
                                <label class="inspector-label">Quality Criteria</label>
                                <div class="space-y-2">
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" v-model="selected.config.checkCompleteness"
                                            class="rounded">
                                        <span class="text-xs">Completeness</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" v-model="selected.config.checkAccuracy" class="rounded">
                                        <span class="text-xs">Accuracy</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" v-model="selected.config.checkTone" class="rounded">
                                        <span class="text-xs">Tone</span>
                                    </label>
                                </div>
                            </section>

                            <section>
                                <label class="inspector-label">Confidence Threshold</label>
                                <input v-model.number="selected.config.confidenceThreshold" type="range" min="0" max="1"
                                    step="0.05" class="w-full">
                                <div class="text-center text-sm font-bold text-indigo-600 mt-1">
                                    {{ (selected.config.confidenceThreshold * 100).toFixed(0) }}%
                                </div>
                            </section>

                            <section>
                                <label class="inspector-label">Max Iterations</label>
                                <input v-model.number="selected.config.maxIterations" type="number" min="1" max="10"
                                    class="v-input">
                            </section>
                        </template>

                        <!-- MCP NODE -->
                        <template v-if="selected.type === 'MCP'">
                            <section>
                                <label class="inspector-label">MCP Server</label>
                                <select v-model="selected.config.serverId" class="v-input mb-3">
                                    <option value="">Select MCP Server...</option>
                                    <option value="azure">‚òÅÔ∏è Azure MCP Server (STDIO)</option>
                                    <option value="google-drive">Google Drive</option>
                                    <option value="slack">Slack</option>
                                    <option value="github">GitHub</option>
                                    <option value="postgres">PostgreSQL</option>
                                    <option value="custom">Custom Server</option>
                                </select>

                                <!-- Azure MCP Server config -->
                                <div v-if="selected.config.serverId === 'azure'" class="rounded-lg border border-blue-200 bg-blue-50 p-3 mb-2 space-y-2">
                                    <div class="flex items-center gap-2 mb-2">
                                        <span class="text-sm">‚òÅÔ∏è</span>
                                        <span class="text-xs font-bold text-blue-700">Azure MCP Server ‚Äî STDIO</span>
                                        <span class="ml-auto text-[10px] px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-700 border border-emerald-300 font-semibold">STDIO</span>
                                    </div>
                                    <div>
                                        <label class="inspector-label">Command</label>
                                        <input v-model="selected.config.command" class="v-input font-mono text-xs mb-1"
                                            placeholder="npx -y @azure/mcp@latest server start" />
                                    </div>
                                    <div>
                                        <label class="inspector-label">Timeout (seconds)</label>
                                        <input v-model.number="selected.config.timeout" type="number" min="30" max="600"
                                            class="v-input text-xs mb-1" placeholder="120" />
                                        <div class="text-[10px] text-blue-500 mt-0.5">First run downloads the package (~30‚Äì60 s). Min: 120 s.</div>
                                    </div>
                                    <div>
                                        <label class="inspector-label">Tool Name <span class="text-slate-400 font-normal normal-case">(optional ‚Äî auto-selected if blank)</span></label>
                                        <input v-model="selected.config.toolName" class="v-input text-xs mb-1"
                                            placeholder="e.g. azmcp_group_list" />
                                    </div>
                                    <div>
                                        <label class="inspector-label">Arguments (JSON, optional)</label>
                                        <textarea v-model="selected.config.argumentsRaw" class="v-input font-mono text-xs h-16"
                                            placeholder='{ "subscription": "my-sub-id" }'></textarea>
                                    </div>
                                    <div class="text-[10px] text-blue-600 border-l-2 border-blue-300 pl-2 leading-relaxed">
                                        Prerequisites: <strong>Node.js</strong> (npx in PATH) + <strong>Azure CLI</strong> (<code>az login</code> on host). Credentials are inherited automatically.
                                    </div>
                                </div>

                                <div v-if="selected.config.serverId === 'custom'">
                                    <input v-model="selected.config.customUrl" placeholder="Server URL or command"
                                        class="v-input mb-2">
                                </div>
                            </section>

                            <section v-if="selected.config.serverId">
                                <label class="inspector-label">Operation</label>
                                <select v-model="selected.config.operation" class="v-input">
                                    <option value="">Select operation...</option>
                                    <option value="tool">Call Tool</option>
                                    <option value="resource">Access Resource</option>
                                    <option value="prompt">Use Prompt</option>
                                </select>
                            </section>

                            <!-- Call Tool fields -->
                            <template v-if="selected.config.operation === 'tool'">
                                <section>
                                    <label class="inspector-label">Server Name</label>
                                    <input v-model="selected.config.serverName" placeholder="e.g., shodan-mcp"
                                        class="v-input mb-2">
                                </section>
                                <section>
                                    <label class="inspector-label">Tool Name</label>
                                    <input v-model="selected.config.toolName" placeholder="e.g., host_lookup"
                                        class="v-input mb-2">
                                </section>
                                <section>
                                    <label class="inspector-label">Endpoint URL</label>
                                    <input v-model="selected.config.endpoint_url"
                                        placeholder="https://api.example.com/endpoint"
                                        class="v-input font-mono text-xs mb-2">
                                </section>
                                <section>
                                    <label class="inspector-label">Method</label>
                                    <select v-model="selected.config.method" class="v-input">
                                        <option value="POST">POST</option>
                                        <option value="GET">GET</option>
                                        <option value="PUT">PUT</option>
                                    </select>
                                </section>
                            </template>

                            <!-- Access Resource fields -->
                            <template v-if="selected.config.operation === 'resource'">
                                <section>
                                    <label class="inspector-label">Server Name</label>
                                    <input v-model="selected.config.serverName" placeholder="e.g., postgres-mcp"
                                        class="v-input mb-2">
                                </section>
                                <section>
                                    <label class="inspector-label">Resource URI</label>
                                    <input v-model="selected.config.endpoint_url"
                                        placeholder="resource://path/to/resource"
                                        class="v-input font-mono text-xs mb-2">
                                </section>
                            </template>

                            <!-- Use Prompt fields -->
                            <template v-if="selected.config.operation === 'prompt'">
                                <section>
                                    <label class="inspector-label">Server Name</label>
                                    <input v-model="selected.config.serverName" placeholder="e.g., analysis-mcp"
                                        class="v-input mb-2">
                                </section>
                                <section>
                                    <label class="inspector-label">Prompt Name</label>
                                    <input v-model="selected.config.toolName" placeholder="e.g., analyze_data"
                                        class="v-input mb-2">
                                </section>
                            </template>
                        </template>

                        <!-- CODE EXECUTION NODE -->
                        <template v-if="selected.type === 'Code'">
                            <section>
                                <label class="inspector-label">Language</label>
                                <select v-model="selected.config.language" class="v-input mb-3">
                                    <option value="python">Python</option>
                                    <option value="typescript">TypeScript</option>
                                    <option value="javascript">JavaScript</option>
                                    <option value="java">Java</option>
                                    <option value="cpp">C++</option>
                                </select>
                            </section>

                            <section>
                                <label class="inspector-label">Code</label>
                                <textarea v-model="selected.config.code"
                                    class="v-input h-48 font-mono text-xs bg-slate-900 text-green-400 p-3"
                                    placeholder="Enter your code here..."></textarea>
                            </section>

                            <section>
                                <label class="inspector-label">Packages / Dependencies</label>
                                <input v-model="selected.config.packages" placeholder="e.g., pandas, numpy"
                                    class="v-input text-xs">
                                <div class="text-[10px] text-slate-400 mt-1">Comma-separated list</div>
                            </section>
                        </template>

                        <!-- LOOP NODE -->
                        <template v-if="selected.type === 'Loop'">
                            <section>
                                <label class="inspector-label">Loop Type</label>
                                <select v-model="selected.config.loopType" class="v-input">
                                    <option value="for">For Loop</option>
                                    <option value="while">While Loop</option>
                                    <option value="for-each">For Each</option>
                                </select>
                            </section>

                            <section v-if="selected.config.loopType === 'for-each'">
                                <label class="inspector-label">Array Variable</label>
                                <input v-model="selected.config.arrayVariable" placeholder="e.g., items"
                                    class="v-input mb-2">
                                <label class="inspector-label">Item Variable Name</label>
                                <input v-model="selected.config.itemVariable" placeholder="e.g., item" class="v-input">
                            </section>

                            <section>
                                <label class="inspector-label">Max Iterations</label>
                                <input v-model.number="selected.config.maxIterations" type="number" class="v-input">
                            </section>
                        </template>

                        <!-- Default/Generic Node Config -->
                        <template
                            v-if="!['Start', 'End', 'Agent', 'Prompt', 'Subagent', 'Conditional', 'API', 'HITL', 'Self-Review', 'MCP', 'Code', 'Loop'].includes(selected.type)">
                            <div class="py-12 text-center">
                                <div class="text-4xl mb-3 opacity-10">‚öôÔ∏è</div>
                                <h4 class="text-xs font-bold text-slate-400 mb-2">Standard Node Configuration</h4>
                                <p class="text-[10px] text-slate-300 px-6">
                                    This {{ selected.type }} node uses standard configuration.
                                    Specific parameters can be configured in the workflow.
                                </p>
                            </div>
                        </template>

                    </div>
                </div>

                <!-- Inspector Footer -->
                <div class="p-4 border-t bg-slate-50 flex gap-2">
                    <button @click="deleteNode"
                        class="flex-1 py-2.5 bg-white border border-red-200 text-red-600 text-xs font-bold uppercase rounded-lg hover:bg-red-50">
                        Delete Node
                    </button>
                    <button @click="selected = null"
                        class="flex-1 py-2.5 bg-indigo-600 text-white text-xs font-bold uppercase rounded-lg shadow-lg hover:bg-indigo-700">
                        Save Config
                    </button>
                </div>
            </aside>
        </div>

        <!-- Tool Configuration Modal -->
        <div v-if="toolConfigModal.show" class="modal-overlay" @click.self="closeToolConfig">
            <div class="modal-content">
                <div class="p-6 border-b flex items-center justify-between bg-slate-50">
                    <div class="flex items-center gap-3">
                        <span class="text-2xl">{{ getToolIcon(toolConfigModal.tool?.type) }}</span>
                        <div>
                            <h3 class="font-bold text-sm text-slate-800">Configure Tool</h3>
                            <p class="text-xs text-slate-500">{{ toolConfigModal.tool?.type }}</p>
                        </div>
                    </div>
                    <button @click="closeToolConfig" class="text-2xl text-slate-400 hover:text-slate-600">√ó</button>
                </div>

                <div class="p-6 space-y-4">
                    <div>
                        <label class="inspector-label">Tool Name</label>
                        <input v-model="toolConfigModal.tool.name" class="v-input" placeholder="Tool name">
                    </div>

                    <div>
                        <label class="flex items-center gap-2 mb-2">
                            <input type="checkbox" v-model="toolConfigModal.tool.enabled" class="rounded">
                            <span class="text-xs font-semibold text-slate-700">Enabled</span>
                        </label>
                    </div>

                    <!-- Code Tool Config -->
                    <template v-if="toolConfigModal.tool?.type === 'code'">
                        <div>
                            <label class="inspector-label">Language</label>
                            <select v-model="toolConfigModal.tool.config.language" class="v-input">
                                <option value="python">Python</option>
                                <option value="javascript">JavaScript</option>
                                <option value="typescript">TypeScript</option>
                                <option value="java">Java</option>
                                <option value="cpp">C++</option>
                            </select>
                        </div>
                        <div>
                            <label class="inspector-label">Code</label>
                            <textarea v-model="toolConfigModal.tool.config.code" class="v-input h-32 font-mono text-xs"
                                placeholder="Enter code..."></textarea>
                        </div>
                    </template>

                    <!-- Subworkflow Config -->
                    <template v-if="toolConfigModal.tool?.type === 'subworkflow'">
                        <div>
                            <label class="inspector-label">Workflow ID</label>
                            <input v-model="toolConfigModal.tool.config.workflowId" class="v-input"
                                placeholder="workflow-123">
                        </div>
                    </template>

                    <!-- Subworkflow Deployment Config -->
                    <template v-if="toolConfigModal.tool?.type === 'subworkflow_deployment'">
                        <div>
                            <label class="inspector-label">Deployment ID</label>
                            <input v-model="toolConfigModal.tool.config.deploymentId" class="v-input"
                                placeholder="deployment-id">
                        </div>
                        <div>
                            <label class="inspector-label">Environment</label>
                            <select v-model="toolConfigModal.tool.config.environment" class="v-input">
                                <option value="production">Production</option>
                                <option value="staging">Staging</option>
                            </select>
                        </div>
                    </template>

                    <!-- MCP Server Config -->
                    <template v-if="toolConfigModal.tool?.type === 'mcp_server'">
                        <div>
                            <label class="inspector-label">Server ID</label>
                            <input v-model="toolConfigModal.tool.config.serverId" class="v-input"
                                placeholder="mcp-server-id">
                        </div>
                        <div>
                            <label class="inspector-label">Operation</label>
                            <input v-model="toolConfigModal.tool.config.operationName" class="v-input"
                                placeholder="operation_name">
                        </div>
                    </template>

                    <!-- Registered Tool (from backend) -->
                    <template v-if="toolConfigModal.tool?.tool_id">
                        <div>
                            <label class="inspector-label">Tool ID</label>
                            <input v-model="toolConfigModal.tool.tool_id" class="v-input text-xs font-mono bg-slate-50"
                                readonly>
                        </div>
                        <div v-if="toolConfigModal.tool?.description">
                            <label class="inspector-label">Description</label>
                            <textarea v-model="toolConfigModal.tool.description"
                                class="v-input h-16 text-xs bg-slate-50" readonly></textarea>
                        </div>
                        <div v-if="toolConfigModal.tool?.tags?.length > 0">
                            <label class="inspector-label">Tags</label>
                            <div class="flex flex-wrap gap-1">
                                <span v-for="tag in toolConfigModal.tool.tags" :key="tag"
                                    class="text-[10px] px-2 py-1 bg-blue-100 text-blue-700 rounded">{{ tag }}</span>
                            </div>
                        </div>
                    </template>
                </div>

                <div class="p-6 border-t bg-slate-50 flex gap-3">
                    <button @click="closeToolConfig"
                        class="flex-1 py-2 border rounded-lg text-xs font-semibold hover:bg-white">
                        Cancel
                    </button>
                    <button @click="saveToolConfig"
                        class="flex-1 py-2 bg-indigo-600 text-white rounded-lg text-xs font-semibold hover:bg-indigo-700">
                        Save Tool
                    </button>
                </div>
            </div>
        </div>
        <!-- </div> -->

        <!-- Workflow Generation Confirmation Modal -->
        <div v-if="showWorkflowDialog" class="fixed inset-0 bg-slate-900/60 flex items-center justify-center z-50"
            @click.self="closeWorkflowDialog">
            <div class="bg-white rounded-lg shadow-xl w-[580px] max-w-[90vw] overflow-hidden">
                <div
                    class="flex items-center justify-between px-4 py-3 border-b bg-gradient-to-r from-indigo-50 to-purple-50">
                    <h3 class="text-sm font-bold text-slate-800">‚ö†Ô∏è Existing Workflow Detected</h3>
                    <button @click="closeWorkflowDialog" class="text-xs text-slate-500 hover:text-slate-700">‚úñ</button>
                </div>
                <div class="p-6">
                    <p class="text-sm text-slate-700 mb-4">You have an existing workflow on the canvas. What would you
                        like to do?</p>
                    <p class="text-xs text-slate-500 mb-6 italic">Tip: Use "Modify Intelligently" to add, remove, or
                        change agents using natural language!</p>
                    <div class="space-y-3">
                        <button @click="handleWorkflowChoice('modify')"
                            class="w-full px-4 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-medium flex items-center justify-between transition-colors border-2 border-indigo-400">
                            <span>‚ú® Modify Intelligently (Recommended)</span>
                            <span class="text-xs opacity-80">AI understands: add, remove, change agents</span>
                        </button>
                        <button @click="handleWorkflowChoice('save')"
                            class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium flex items-center justify-between transition-colors">
                            <span>üíæ Save & Clear</span>
                            <span class="text-xs opacity-80">Save current workflow and start fresh</span>
                        </button>
                        <button @click="handleWorkflowChoice('discard')"
                            class="w-full px-4 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium flex items-center justify-between transition-colors">
                            <span>üóëÔ∏è Discard & Clear</span>
                            <span class="text-xs opacity-80">Delete current workflow and start fresh</span>
                        </button>
                        <button @click="handleWorkflowChoice('append')"
                            class="w-full px-4 py-3 bg-slate-600 hover:bg-slate-700 text-white rounded-lg text-sm font-medium flex items-center justify-between transition-colors">
                            <span>‚ûï Append (Legacy)</span>
                            <span class="text-xs opacity-80">Add new agents without context</span>
                        </button>
                        <button @click="closeWorkflowDialog"
                            class="w-full px-4 py-3 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-lg text-sm font-medium transition-colors">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow Input Modal -->
        <div v-if="showInputModal" class="fixed inset-0 bg-slate-900/60 flex items-center justify-center z-50"
            @click.self="closeInputModal">
            <div class="bg-white rounded-lg shadow-xl w-[600px] max-w-[90vw] overflow-hidden">
                <div
                    class="flex items-center justify-between px-4 py-3 border-b bg-gradient-to-r from-indigo-50 to-blue-50">
                    <h3 class="text-sm font-bold text-slate-800">üéØ Workflow Input</h3>
                    <button @click="closeInputModal" class="text-xs text-slate-500 hover:text-slate-700">‚úñ</button>
                </div>
                <div class="p-6">
                    <p class="text-sm text-slate-700 mb-4">Provide your input/question for the workflow (JSON format):
                    </p>
                    <textarea v-model="workflowInput"
                        placeholder='{"message": "Write a blog post about artificial intelligence"}'
                        class="w-full h-48 px-3 py-2 text-sm font-mono border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                    <p class="text-xs text-slate-500 mt-1">Use "message" key for your input. Example: {"message": "your
                        question here"}</p>
                    <div class="mt-4 flex items-center justify-end gap-3">
                        <button @click="closeInputModal"
                            class="px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-lg text-sm font-medium transition-colors">
                            Cancel
                        </button>
                        <button @click="executeWithInput"
                            class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-medium transition-colors">
                            ‚ñ∂ Execute
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow Execution Modal -->
        <div v-if="showExecutionModal" class="fixed inset-0 bg-slate-900/60 flex items-center justify-center z-50"
            @click.self="closeExecutionModal">
            <div class="bg-white rounded-lg shadow-xl w-[720px] max-w-[90vw] max-h-[80vh] overflow-hidden">
                <div class="flex items-center justify-between px-4 py-3 border-b">
                    <h3 class="text-sm font-bold text-slate-800">Workflow Execution Result</h3>
                    <button @click="closeExecutionModal" class="text-xs text-slate-500 hover:text-slate-700">‚úñ</button>
                </div>
                <div class="p-4 overflow-auto" style="max-height: 60vh;">
                    <pre
                        class="text-xs text-slate-800 whitespace-pre-wrap">{{ executionResult ? JSON.stringify(executionResult, null, 2) : 'No result yet.' }}</pre>
                </div>
                <div class="px-4 py-3 border-t bg-slate-50 text-[11px] text-slate-500">
                    Close this dialog to continue editing. Runs use the /workflows/execute endpoint.
                </div>
            </div>
        </div>

        <!-- Load Workflow Modal -->
        <div v-if="showLoadModal" class="fixed inset-0 bg-slate-900/60 flex items-center justify-center z-50"
            @click.self="showLoadModal = false">
            <div
                class="bg-white rounded-lg shadow-xl w-[500px] max-w-[90vw] max-h-[600px] flex flex-col overflow-hidden">
                <div
                    class="flex items-center justify-between px-4 py-3 border-b bg-gradient-to-r from-indigo-50 to-blue-50">
                    <h3 class="text-sm font-bold text-slate-800">üìÇ Load Workflow</h3>
                    <button @click="showLoadModal = false"
                        class="text-xs text-slate-500 hover:text-slate-700">‚úñ</button>
                </div>

                <!-- Manual ID Entry -->
                <div class="p-4 border-b bg-slate-50">
                    <div class="text-xs font-semibold text-slate-600 mb-2">Load by Workflow ID</div>
                    <div class="flex gap-2">
                        <input v-model="manualWorkflowId" @keydown.enter="loadManualId"
                            placeholder="Enter workflow ID (e.g., wf_abc123...)"
                            class="flex-1 px-3 py-2 text-xs border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button @click="loadManualId" :disabled="!manualWorkflowId.trim()"
                            class="px-4 py-2 text-xs font-semibold text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 disabled:bg-slate-300 disabled:cursor-not-allowed">
                            Load
                        </button>
                    </div>
                </div>

                <!-- Draft List -->
                <div class="flex-1 overflow-y-auto p-4">
                    <div class="text-xs font-semibold text-slate-600 mb-2">Or Select from Saved Drafts</div>
                    <div v-if="isLoadingDrafts" class="text-center py-8">
                        <div
                            class="w-6 h-6 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin mx-auto mb-2">
                        </div>
                        <span class="text-xs text-slate-500">Loading drafts...</span>
                    </div>
                    <div v-else-if="draftWorkflows.length === 0" class="text-center py-8 text-slate-400 text-xs">
                        No draft workflows found. Create and save a workflow first.
                    </div>
                    <div v-else class="space-y-2">
                        <div v-for="wf in draftWorkflows" :key="wf.workflow_id"
                            @click="loadSelectedDraft(wf.workflow_id)"
                            class="p-3 border border-slate-200 rounded-lg hover:border-indigo-300 hover:bg-indigo-50 cursor-pointer transition-all">
                            <div class="flex items-center justify-between">
                                <div class="text-xs font-semibold text-slate-700">{{ wf.name || 'Untitled Workflow' }}
                                </div>
                                <span class="px-2 py-0.5 text-[10px] font-medium bg-slate-100 text-slate-500 rounded">{{
                                    wf.execution_model }}</span>
                            </div>
                            <div class="text-[10px] text-slate-400 mt-1">
                                {{ wf.workflow_id }} ‚Ä¢ {{ wf.agent_count }} agent(s)
                            </div>
                        </div>
                    </div>
                </div>

                <div class="px-4 py-3 border-t bg-slate-50 text-[11px] text-slate-500">
                    Select a draft or enter a workflow ID to load it onto the canvas.
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        // API Configuration
        const API_BASE_URL = 'http://localhost:8000';

        // Backend API Functions
        const workflowAPI = {
            // Design workflow from natural language prompt
            async designFromPrompt(prompt, defaultLlm = null) {
                try {
                    // Don't send default_llm - let backend use LLMManager defaults
                    const response = await fetch(`${API_BASE_URL}/workflows/design/prompt?prompt=${encodeURIComponent(prompt)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ default_llm: {} })  // Empty = use backend defaults
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to design workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow design API error:', error);
                    throw error;
                }
            },

            // Save workflow to backend (canvas format)
            async saveCanvas(canvasNodes, connections, workflowName = null, saveAs = 'draft', executionModel = 'sequential', workflowId = null) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/canvas/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            canvas_nodes: canvasNodes,
                            connections: connections,
                            workflow_name: workflowName,
                            save_as: saveAs,
                            execution_model: executionModel,
                            workflow_id: workflowId  // Preserve existing ID if provided
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to save workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow save API error:', error);
                    throw error;
                }
            },

            // Convert canvas to backend format
            async canvasToBackend(canvasNodes, connections, workflowName = null) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/canvas/to-backend`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            canvas_nodes: canvasNodes,
                            connections: connections,
                            workflow_name: workflowName
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to convert workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow convert API error:', error);
                    throw error;
                }
            },

            // Load workflow by ID (expects backend to return workflow + agents)
            async loadWorkflow(workflowId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/${workflowId}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to load workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow load API error:', error);
                    throw error;
                }
            },

            // Convert backend workflow to canvas format
            async backendToCanvas(workflow, agents) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/backend/to-canvas`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            workflow,
                            agents
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to convert backend workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow backend-to-canvas API error:', error);
                    throw error;
                }
            },

            // Execute workflow run
            async execute(workflowId, mode = 'test', version = null, inputPayload = {}) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/execute`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            workflow_id: workflowId,
                            mode,
                            version,
                            input_payload: inputPayload
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to execute workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow execute API error:', error);
                    throw error;
                }
            },

            // List all draft workflows
            async listDrafts() {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/draft/list`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to load draft list');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow list drafts API error:', error);
                    throw error;
                }
            },

            // Modify existing workflow via natural language (HITL)
            // Uses LLM-based intent detection - understands any natural language
            async modifyWorkflow(prompt, existingWorkflow, existingAgents, conversationHistory = []) {
                try {
                    const response = await fetch(`${API_BASE_URL}/workflows/design/modify`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: prompt,
                            existing_workflow: existingWorkflow,
                            existing_agents: existingAgents,
                            conversation_history: conversationHistory
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to modify workflow');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Workflow modify API error:', error);
                    throw error;
                }
            }
        };

        const agentAPI = {
            // Get all agents from registry (master list)
            async getMasterList() {
                try {
                    const response = await fetch(`${API_BASE_URL}/agents/registry/master-list`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch agents');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Agent registry API error:', error);
                    throw error;
                }
            },

            // Get all agent templates (static + created)
            async getAllTemplates() {
                try {
                    const response = await fetch(`${API_BASE_URL}/agents/templates/all`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch templates');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Agent templates API error:', error);
                    throw error;
                }
            },

            // Get agent by ID
            async getAgent(agentId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/agents/${agentId}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch agent');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Agent fetch API error:', error);
                    throw error;
                }
            }
        };

        // Tool API Functions
        const toolAPI = {
            // Discover tools from AgentTools directory
            async discoverTools() {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/discover`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to discover tools');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool discovery API error:', error);
                    throw error;
                }
            },

            // Get all registered tools
            async listTools() {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/list`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch tools');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool list API error:', error);
                    throw error;
                }
            },

            // Get specific tool by ID
            async getTool(toolId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/${toolId}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch tool');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool fetch API error:', error);
                    throw error;
                }
            },

            // Search tools by query
            async searchTools(query) {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/search?q=${encodeURIComponent(query)}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to search tools');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool search API error:', error);
                    throw error;
                }
            },

            // List tools by type (local, mcp, api, crewai)
            async listToolsByType(toolType) {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/list/type/${toolType}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch tools by type');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool type filter API error:', error);
                    throw error;
                }
            },

            // Get tools assigned to an agent
            async getAgentTools(agentId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/agent/${agentId}`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to fetch agent tools');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Agent tools API error:', error);
                    throw error;
                }
            },

            // Check tool system health
            async healthCheck() {
                try {
                    const response = await fetch(`${API_BASE_URL}/tools/health`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Tool system unhealthy');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Tool health check API error:', error);
                    throw error;
                }
            }
        };

        createApp({
            setup() {
                const selected = ref(null);
                const activeTab = ref('overview');
                const activeNodes = ref([]);
                const connections = ref([]);
                const dragNode = ref(null);
                const showToolDropdown = ref(false);
                const searchQuery = ref('');
                const zoomLevel = ref(1);
                const linkSource = ref(null);
                const fileInput = ref(null);
                const toolConfigModal = ref({
                    show: false,
                    tool: null,
                    toolIndex: null
                });
                const agentSearchQuery = ref('');
                const leftPaneTab = ref('chat');
                const promptPaneWidth = ref(400);
                const isResizing = ref(false);
                const workflowPrompt = ref('');
                const isGenerating = ref(false);
                const generationStatus = ref('');
                const generatedWorkflows = ref([]);
                const backendAgents = ref([]);
                const workflowName = ref('');
                const workflowExecutionModel = ref('sequential');
                const saveStatus = ref('');
                const workflowSaved = ref(false);
                const currentWorkflowId = ref(null);
                const workflowModified = ref(false);
                const currentThreadId = ref(null);
                const chatMessages = ref([]);
                const chatInput = ref('');
                const chatSessionId = ref(null);
                const isSendingMessage = ref(false);
                const isExecuting = ref(false);
                const executionResult = ref(null);
                const showExecutionModal = ref(false);
                const showInputModal = ref(false);
                const workflowInput = ref('{}');
                const showWorkflowDialog = ref(false);
                const pendingWorkflowGeneration = ref(false);
                const workflowState = ref('empty');

                // Load Modal State
                const showLoadModal = ref(false);
                const draftWorkflows = ref([]);
                const isLoadingDrafts = ref(false);
                const manualWorkflowId = ref('');

                // Tool System State
                const registeredTools = ref([]);
                const toolsLoaded = ref(false);
                const toolsLoadError = ref(null);
                const toolDiscoveryStatus = ref('');
                const isDiscoveringTools = ref(false);

                // Session Management State (Database-backed sessions)
                const sessionHistory = ref([]);  // List of user's chat sessions
                const isLoadingSessions = ref(false);
                const sessionLoadError = ref(null);
                const showSessionHistory = ref(false);  // Toggle session history panel

                // Execution Transparency State (Real-time step visibility)
                const executionSteps = ref([]);  // Array of step objects
                const currentRunId = ref(null);
                const executionWebSocket = ref(null);
                const isExecutionInProgress = ref(false);

                // A2UI SSE State (App Manager streaming)
                const a2uiSurfaces = ref({});          // surfaceId ‚Üí { components, dataModel, ready }
                const a2uiActiveSteps = ref([]);       // derived: /steps from active surface
                const a2uiFinalOutput = ref('');       // derived: /final_output from active surface
                const a2uiTitle = ref('');             // derived: /title from active surface
                const a2uiStreamActive = ref(false);   // true while SSE stream is open
                const a2uiAbortController = ref(null); // AbortController for current stream
                const a2uiActiveSurfaceId = ref(null); // currently active surfaceId

                // HITL Review State
                const hitlEditMode = ref(false);
                const hitlEditContent = ref('');
                const hitlSubmitting = ref(false);

                // A2UI JSONL line processor
                const processA2UILine = (jsonLine) => {
                    try {
                        const msg = JSON.parse(jsonLine);
                        if (!msg.type || !msg.surfaceId) return;

                        const sid = msg.surfaceId;

                        if (msg.type === 'surfaceUpdate') {
                            if (!a2uiSurfaces.value[sid]) {
                                a2uiSurfaces.value[sid] = { components: {}, dataModel: {}, ready: false };
                            }
                            (msg.components || []).forEach(c => {
                                a2uiSurfaces.value[sid].components[c.id] = c;
                            });
                        } else if (msg.type === 'dataModelUpdate') {
                            if (!a2uiSurfaces.value[sid]) {
                                a2uiSurfaces.value[sid] = { components: {}, dataModel: {}, ready: false };
                            }
                            Object.assign(a2uiSurfaces.value[sid].dataModel, msg.data || {});
                            if (sid === a2uiActiveSurfaceId.value) {
                                const dm = a2uiSurfaces.value[sid].dataModel;
                                if (dm.steps !== undefined) a2uiActiveSteps.value = dm.steps || [];
                                if (dm.final_output !== undefined) a2uiFinalOutput.value = dm.final_output || '';
                                if (dm.title !== undefined) a2uiTitle.value = dm.title || '';
                            }
                        } else if (msg.type === 'beginRendering') {
                            if (a2uiSurfaces.value[sid]) {
                                a2uiSurfaces.value[sid].ready = true;
                            }
                            a2uiActiveSurfaceId.value = sid;
                            const dm = (a2uiSurfaces.value[sid] || {}).dataModel || {};
                            a2uiActiveSteps.value = dm.steps || [];
                            a2uiFinalOutput.value = dm.final_output || '';
                            a2uiTitle.value = dm.title || '';
                        } else if (msg.type === 'deleteSurface') {
                            if (a2uiSurfaces.value[sid]) {
                                delete a2uiSurfaces.value[sid];
                            }
                            if (sid === a2uiActiveSurfaceId.value) {
                                a2uiActiveSurfaceId.value = null;
                                a2uiActiveSteps.value = [];
                                a2uiFinalOutput.value = '';
                            }
                        }
                    } catch (e) {
                        console.warn('[A2UI] Failed to parse JSONL line:', jsonLine, e);
                    }
                };

                // A2UI SSE stream client (fetch + ReadableStream; POST endpoint, so EventSource not usable)
                const connectA2UIStream = async (appId, message, sessionId = null) => {
                    if (a2uiAbortController.value) {
                        a2uiAbortController.value.abort();
                    }
                    a2uiSurfaces.value = {};
                    a2uiActiveSteps.value = [];
                    a2uiFinalOutput.value = '';
                    a2uiTitle.value = '';
                    a2uiActiveSurfaceId.value = null;
                    a2uiStreamActive.value = true;

                    const controller = new AbortController();
                    a2uiAbortController.value = controller;

                    try {
                        const response = await fetch(`${API_BASE_URL}/api/applications/${appId}/chat/stream`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message, session_id: sessionId }),
                            signal: controller.signal,
                        });

                        if (!response.ok) {
                            throw new Error(`A2UI SSE stream failed: ${response.status}`);
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop();
                            for (const line of lines) {
                                const trimmed = line.trim();
                                if (trimmed.startsWith('data: ')) {
                                    const jsonLine = trimmed.slice(6);
                                    if (jsonLine && jsonLine !== '[DONE]') {
                                        processA2UILine(jsonLine);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        if (e.name !== 'AbortError') {
                            console.error('[A2UI] Stream error:', e);
                        }
                    } finally {
                        a2uiStreamActive.value = false;
                        a2uiAbortController.value = null;
                    }
                };

                const disconnectA2UIStream = () => {
                    if (a2uiAbortController.value) {
                        a2uiAbortController.value.abort();
                        a2uiAbortController.value = null;
                    }
                    a2uiStreamActive.value = false;
                };

                // WebSocket connection for execution transparency
                const connectExecutionWebSocket = (runId) => {
                    return new Promise((resolve, reject) => {
                        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsHost = API_BASE_URL.replace(/^https?:\/\//, '');
                        const wsUrl = `${wsProtocol}//${wsHost}/ws/execution/${runId}`;

                        console.log(`[Transparency] Connecting to WebSocket: ${wsUrl}`);

                        const ws = new WebSocket(wsUrl);

                        ws.onopen = () => {
                            console.log(`[Transparency] WebSocket connected for run: ${runId}`);
                            executionWebSocket.value = ws;
                            resolve(ws);
                        };

                        ws.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                console.log(`[Transparency] Event received:`, data.event, data);
                                handleExecutionEvent(data);
                            } catch (e) {
                                console.error('[Transparency] Failed to parse event:', e);
                            }
                        };

                        ws.onerror = (error) => {
                            console.error('[Transparency] WebSocket error:', error);
                            reject(error);
                        };

                        ws.onclose = (event) => {
                            console.log(`[Transparency] WebSocket closed: ${event.code}`);
                            executionWebSocket.value = null;
                            isExecutionInProgress.value = false;
                        };

                        // Timeout after 5 seconds
                        setTimeout(() => {
                            if (ws.readyState !== WebSocket.OPEN) {
                                ws.close();
                                reject(new Error('WebSocket connection timeout'));
                            }
                        }, 5000);
                    });
                };

                // Handle execution events from WebSocket
                const handleExecutionEvent = (event) => {
                    const { event: eventType, run_id, step_id, timestamp, payload } = event;
                    console.log(`[Transparency] Processing event: ${eventType}`, { run_id, step_id, payload });

                    switch (eventType) {
                        case 'run_started':
                            console.log('[Transparency] Handling run_started');
                            executionSteps.value = [];
                            isExecutionInProgress.value = true;
                            // Add a "run started" message to chat
                            chatMessages.value.push({
                                role: 'system',
                                type: 'execution_start',
                                content: `üöÄ Workflow execution started`,
                                timestamp: new Date().toLocaleTimeString(),
                                run_id: run_id
                            });
                            console.log(`[Transparency] chatMessages count after run_started: ${chatMessages.value.length}`);
                            break;

                        case 'step_started': {
                            console.log(`[Transparency] Handling step_started: ${payload?.step_name}`);
                            const newStep = {
                                step_id: step_id,
                                step_name: payload.step_name || 'Processing',
                                step_type: payload.step_type || 'agent',
                                status: 'running',
                                input_summary: payload.input_summary,
                                started_at: timestamp
                            };
                            executionSteps.value.push(newStep);
                            // Update chat with step progress
                            chatMessages.value.push({
                                role: 'system',
                                type: 'step_started',
                                content: `‚è≥ ${payload.step_name || 'Agent'} started...`,
                                timestamp: new Date().toLocaleTimeString(),
                                step_id: step_id,
                                step_name: payload.step_name,
                                step_type: payload.step_type
                            });
                            console.log(`[Transparency] chatMessages count after step_started: ${chatMessages.value.length}`);
                            break;
                        }

                        case 'step_completed': {
                            console.log(`[Transparency] Handling step_completed: ${step_id}`, payload);
                            // Find and update the step in executionSteps
                            const stepIdx = executionSteps.value.findIndex(s => s.step_id === step_id);
                            if (stepIdx !== -1) {
                                executionSteps.value[stepIdx].status = 'completed';
                                executionSteps.value[stepIdx].output_summary = payload.output_summary;
                                executionSteps.value[stepIdx].completed_at = timestamp;
                            }
                            const stepName = stepIdx !== -1 ? executionSteps.value[stepIdx]?.step_name : 'Step';

                            // Get output preview from payload
                            const outputPreview = payload.output_preview || '';

                            // Find and UPDATE the existing step_started message (don't add new one)
                            const msgIdx = chatMessages.value.findIndex(m =>
                                m.type === 'step_started' && m.step_id === step_id
                            );
                            if (msgIdx !== -1) {
                                // Update existing message to show completed with preview
                                chatMessages.value[msgIdx].type = 'step_completed';
                                chatMessages.value[msgIdx].content = `‚úÖ ${stepName} completed`;
                                chatMessages.value[msgIdx].output_preview = outputPreview;
                            } else {
                                // Fallback: add new message if started message not found
                                chatMessages.value.push({
                                    role: 'system',
                                    type: 'step_completed',
                                    content: `‚úÖ ${stepName} completed`,
                                    timestamp: new Date().toLocaleTimeString(),
                                    step_id: step_id,
                                    output_preview: outputPreview
                                });
                            }
                            console.log(`[Transparency] chatMessages count after step_completed: ${chatMessages.value.length}`);
                            break;
                        }

                        case 'step_failed': {
                            console.log(`[Transparency] Handling step_failed: ${step_id}`);
                            const failedStepIdx = executionSteps.value.findIndex(s => s.step_id === step_id);
                            let failedStepName = 'Step';
                            if (failedStepIdx !== -1) {
                                executionSteps.value[failedStepIdx].status = 'failed';
                                executionSteps.value[failedStepIdx].error = payload.error;
                                failedStepName = executionSteps.value[failedStepIdx].step_name || 'Step';
                            }

                            // Find and UPDATE the existing step_started message
                            const failedMsgIdx = chatMessages.value.findIndex(m =>
                                m.type === 'step_started' && m.step_id === step_id
                            );
                            if (failedMsgIdx !== -1) {
                                chatMessages.value[failedMsgIdx].type = 'step_failed';
                                chatMessages.value[failedMsgIdx].content = `‚ùå ${failedStepName} failed: ${payload.error}`;
                                chatMessages.value[failedMsgIdx].error = true;
                            } else {
                                chatMessages.value.push({
                                    role: 'system',
                                    type: 'step_failed',
                                    content: `‚ùå ${failedStepName} failed: ${payload.error}`,
                                    timestamp: new Date().toLocaleTimeString(),
                                    step_id: step_id,
                                    error: true
                                });
                            }
                            console.log(`[Transparency] chatMessages count after step_failed: ${chatMessages.value.length}`);
                            break;
                        }

                        case 'run_completed':
                            console.log('[Transparency] Handling run_completed', payload);
                            isExecutionInProgress.value = false;

                            // Check if this is a HITL interrupt (workflow paused for human review)
                            if (payload.status === 'interrupted' && payload.interrupt) {
                                console.log('[Transparency] HITL interrupt detected, showing review panel');
                                const interruptData = payload.interrupt;
                                chatMessages.value.push({
                                    role: 'hitl_review',
                                    hitl: {
                                        run_id: interruptData.run_id || run_id,
                                        workflow_id: interruptData.workflow_id || '',
                                        node_id: interruptData.node_id || '',
                                        title: interruptData.title || 'Human Review Required',
                                        message: interruptData.message || 'Please review and take action.',
                                        priority: interruptData.priority || 'medium',
                                        allowed_decisions: interruptData.allowed_decisions || ['approve', 'reject'],
                                        state_snapshot: interruptData.state_snapshot || null,
                                    },
                                    decided: null,
                                    showSnapshot: false,
                                    timestamp: new Date().toLocaleTimeString(),
                                });
                                // Reset edit mode
                                hitlEditMode.value = false;
                                hitlEditContent.value = '';
                            } else if (payload.final_response) {
                                // Normal completion ‚Äî add final response to chat
                                chatMessages.value.push({
                                    role: 'assistant',
                                    content: payload.final_response,
                                    timestamp: new Date().toLocaleTimeString(),
                                    run_id: run_id,
                                    execution_completed: true
                                });
                            }
                            console.log(`[Transparency] chatMessages count after run_completed: ${chatMessages.value.length}`);
                            // Close WebSocket ‚Äî but NOT if interrupted (HITL pause).
                            // The WebSocket must stay open so the resumed workflow
                            // can stream its remaining step events through it.
                            if (payload.status !== 'interrupted') {
                                if (executionWebSocket.value) {
                                    executionWebSocket.value.close();
                                }
                            }
                            isSendingMessage.value = false;
                            break;

                        case 'run_failed':
                            console.log('[Transparency] Handling run_failed');
                            isExecutionInProgress.value = false;
                            chatMessages.value.push({
                                role: 'assistant',
                                content: `‚ùå Execution failed: ${payload.error}`,
                                timestamp: new Date().toLocaleTimeString(),
                                run_id: run_id,
                                error: true
                            });
                            if (executionWebSocket.value) {
                                executionWebSocket.value.close();
                            }
                            isSendingMessage.value = false;
                            break;

                        default:
                            console.warn(`[Transparency] Unknown event type: ${eventType}`);
                    }
                };

                // Disconnect WebSocket
                const disconnectExecutionWebSocket = () => {
                    if (executionWebSocket.value) {
                        executionWebSocket.value.close();
                        executionWebSocket.value = null;
                    }
                    isExecutionInProgress.value = false;
                };

                const markWorkflowModified = () => {
                    workflowModified.value = true;
                    workflowSaved.value = false;
                    workflowState.value = activeNodes.value.length === 0 ? 'empty' : 'unsaved';
                };

                const resetCanvasState = () => {
                    activeNodes.value = [];
                    connections.value = [];
                    selected.value = null;
                    currentWorkflowId.value = null;
                    currentThreadId.value = null;
                    workflowModified.value = false;
                    workflowSaved.value = false;
                    workflowState.value = 'empty';
                };
                const offset = { x: 0, y: 0 };

                // Agent Templates Library
                const agentTemplates = [
                    {
                        name: "Research Analyst",
                        icon: "üî¨",
                        description: "Conducts comprehensive research using web search and analysis",
                        prompt: "You are a Research Analyst. Your role is to conduct thorough research on given topics, synthesize information from multiple sources, and provide well-structured analysis with citations.",
                        tools: ["Web Search", "Web Fetch", "Document Analysis"],
                        variables: [
                            { name: "research_topic", type: "string", defaultValue: "" },
                            { name: "depth", type: "string", defaultValue: "comprehensive" }
                        ]
                    },
                    {
                        name: "Customer Support Agent",
                        icon: "üí¨",
                        description: "Handles customer inquiries with empathy and efficiency",
                        prompt: "You are a Customer Support Agent. Provide helpful, empathetic responses to customer inquiries. Always maintain a professional and friendly tone.",
                        tools: ["Slack", "Email", "Knowledge Base"],
                        variables: [
                            { name: "customer_id", type: "string", defaultValue: "" },
                            { name: "issue_type", type: "string", defaultValue: "general" }
                        ]
                    },
                    {
                        name: "Data Analyst",
                        icon: "üìä",
                        description: "Analyzes data and generates insights with visualizations",
                        prompt: "You are a Data Analyst. Analyze datasets, identify patterns, and generate actionable insights. Present findings clearly with appropriate visualizations.",
                        tools: ["Python Code", "SQL Query", "Chart Generator"],
                        variables: [
                            { name: "dataset", type: "object", defaultValue: "" },
                            { name: "analysis_type", type: "string", defaultValue: "exploratory" }
                        ]
                    },
                    {
                        name: "Content Writer",
                        icon: "‚úçÔ∏è",
                        description: "Creates engaging content for various formats and audiences",
                        prompt: "You are a Content Writer. Create compelling, well-structured content tailored to the specified format and audience. Maintain consistent tone and style.",
                        tools: ["Grammar Check", "SEO Optimizer", "Plagiarism Check"],
                        variables: [
                            { name: "topic", type: "string", defaultValue: "" },
                            { name: "format", type: "string", defaultValue: "blog" },
                            { name: "tone", type: "string", defaultValue: "professional" }
                        ]
                    },
                    {
                        name: "Code Reviewer",
                        icon: "üë®‚Äçüíª",
                        description: "Reviews code for quality, security, and best practices",
                        prompt: "You are a Code Reviewer. Analyze code for quality, security vulnerabilities, performance issues, and adherence to best practices. Provide constructive feedback.",
                        tools: ["Code Analysis", "Security Scan", "GitHub"],
                        variables: [
                            { name: "code_snippet", type: "string", defaultValue: "" },
                            { name: "language", type: "string", defaultValue: "python" }
                        ]
                    },
                    {
                        name: "Project Manager",
                        icon: "üìã",
                        description: "Manages tasks, timelines, and team coordination",
                        prompt: "You are a Project Manager. Coordinate tasks, manage timelines, and facilitate team communication. Ensure project milestones are met efficiently.",
                        tools: ["Jira", "Slack", "Calendar"],
                        variables: [
                            { name: "project_name", type: "string", defaultValue: "" },
                            { name: "phase", type: "string", defaultValue: "planning" }
                        ]
                    },
                    {
                        name: "Sales Assistant",
                        icon: "üíº",
                        description: "Assists with sales inquiries and lead qualification",
                        prompt: "You are a Sales Assistant. Engage with potential customers, qualify leads, and provide product information. Focus on understanding customer needs.",
                        tools: ["CRM", "Email", "Product Catalog"],
                        variables: [
                            { name: "lead_info", type: "object", defaultValue: "" },
                            { name: "product_interest", type: "string", defaultValue: "" }
                        ]
                    },
                    {
                        name: "HR Coordinator",
                        icon: "üë•",
                        description: "Manages HR processes and employee communications",
                        prompt: "You are an HR Coordinator. Handle employee inquiries, coordinate HR processes, and maintain professional communication. Ensure compliance with policies.",
                        tools: ["HRIS", "Email", "Document Management"],
                        variables: [
                            { name: "employee_id", type: "string", defaultValue: "" },
                            { name: "request_type", type: "string", defaultValue: "" }
                        ]
                    },
                    {
                        name: "Financial Analyst",
                        icon: "üí∞",
                        description: "Analyzes financial data and generates reports",
                        prompt: "You are a Financial Analyst. Analyze financial data, identify trends, and generate comprehensive reports. Provide actionable recommendations.",
                        tools: ["Excel", "Financial API", "Chart Generator"],
                        variables: [
                            { name: "financial_data", type: "object", defaultValue: "" },
                            { name: "report_period", type: "string", defaultValue: "quarterly" }
                        ]
                    },
                    {
                        name: "Legal Reviewer",
                        icon: "‚öñÔ∏è",
                        description: "Reviews documents for legal compliance and risks",
                        prompt: "You are a Legal Reviewer. Review documents for legal compliance, identify potential risks, and suggest necessary modifications. Maintain confidentiality.",
                        tools: ["Document Review", "Legal Database", "Contract Analysis"],
                        variables: [
                            { name: "document_type", type: "string", defaultValue: "" },
                            { name: "jurisdiction", type: "string", defaultValue: "" }
                        ]
                    },
                    {
                        name: "Marketing Strategist",
                        icon: "üìà",
                        description: "Develops marketing strategies and campaign plans",
                        prompt: "You are a Marketing Strategist. Develop comprehensive marketing strategies, analyze market trends, and create campaign plans that drive engagement.",
                        tools: ["Analytics", "Social Media API", "Email Marketing"],
                        variables: [
                            { name: "campaign_goal", type: "string", defaultValue: "" },
                            { name: "target_audience", type: "string", defaultValue: "" }
                        ]
                    },
                    {
                        name: "Quality Assurance Tester",
                        icon: "üîç",
                        description: "Tests software for bugs and quality issues",
                        prompt: "You are a QA Tester. Systematically test software, identify bugs, document issues clearly, and verify fixes. Ensure high quality standards.",
                        tools: ["Test Framework", "Bug Tracker", "Code Analysis"],
                        variables: [
                            { name: "test_scope", type: "string", defaultValue: "" },
                            { name: "priority", type: "string", defaultValue: "high" }
                        ]
                    }
                ];

                // Complete Node Library (All 16 node types)
                const nodeLibrary = {
                    "Entry/Exit": [
                        {
                            type: 'Start',
                            label: 'Start',
                            icon: '‚ñ∂Ô∏è',
                            color: '#10b981',
                            description: 'Workflow entry point',
                            config: {
                                inputVariables: [
                                    { name: 'query', type: 'string', required: true, description: '' }
                                ]
                            }
                        },
                        {
                            type: 'End',
                            label: 'End',
                            icon: '‚èπÔ∏è',
                            color: '#64748b',
                            description: 'Workflow exit point',
                            config: {
                                outputVariables: [
                                    { name: 'result', type: 'string' }
                                ]
                            }
                        }
                    ],
                    "Agents": [
                        {
                            type: 'Agent',
                            label: 'Agent',
                            icon: 'üî∂',
                            color: '#f59e0b',
                            description: 'Autonomous AI agent',
                            config: {
                                prompt: '',
                                model: {
                                    provider: 'anthropic',
                                    modelName: 'claude-sonnet-4-5-20250514',
                                    displayName: 'Claude Sonnet 4.5'
                                },
                                tools: [],
                                maxIterations: 5,
                                variables: [],
                                routing: {
                                    strategy: 'llm-driven',
                                    routes: []
                                },
                                temperature: 0.7,
                                topP: 0.9,
                                maxTokens: 4000,
                                memory: {
                                    enabled: true,
                                    type: 'short-term'
                                },
                                adornments: []
                            }
                        },
                        {
                            type: 'Subagent',
                            label: 'Subagent',
                            icon: 'üë•',
                            color: '#f59e0b',
                            description: 'Delegate to specialist',
                            config: {
                                targetAgentId: '',
                                task: '',
                                prompt: '',
                                model: {
                                    provider: 'anthropic',
                                    modelName: 'claude-sonnet-4-5-20250514',
                                    displayName: 'Claude Sonnet 4.5'
                                },
                                tools: [],
                                maxIterations: 5,
                                variables: [],
                                routing: {
                                    strategy: 'llm-driven',
                                    routes: []
                                },
                                temperature: 0.7,
                                topP: 0.9,
                                maxTokens: 4000,
                                memory: {
                                    enabled: true,
                                    type: 'short-term'
                                },
                                adornments: []
                            }
                        }
                    ],
                    "LLM": [
                        {
                            type: 'Prompt',
                            label: 'Prompt',
                            icon: 'üí¨',
                            color: '#ec4899',
                            description: 'Direct LLM call',
                            config: {
                                prompt: '',
                                model: {
                                    provider: 'anthropic',
                                    modelName: 'claude-sonnet-4-5-20250514',
                                    displayName: 'Claude Sonnet 4.5'
                                },
                                tools: [],
                                maxIterations: 5,
                                variables: [],
                                routing: {
                                    strategy: 'llm-driven',
                                    routes: []
                                },
                                temperature: 0.7,
                                topP: 0.9,
                                maxTokens: 4000,
                                memory: {
                                    enabled: false,
                                    type: 'short-term'
                                },
                                adornments: []
                            }
                        }
                    ],
                    "Logic": [
                        {
                            type: 'Conditional',
                            label: 'Conditional',
                            icon: 'üîÄ',
                            color: '#8b5cf6',
                            description: 'If/elif/else branching',
                            config: {
                                branches: [
                                    { condition: '', targetNodeId: '' },
                                    { condition: '', targetNodeId: '' }
                                ]
                            }
                        },
                        {
                            type: 'Loop',
                            label: 'Loop',
                            icon: 'üîÑ',
                            color: '#8b5cf6',
                            description: 'Iterate over items',
                            config: {
                                loopType: 'for-each',
                                arrayVariable: '',
                                itemVariable: 'item',
                                maxIterations: 100
                            }
                        },
                        {
                            type: 'Map',
                            label: 'Map',
                            icon: 'üîÅ',
                            color: '#8b5cf6',
                            description: 'Parallel execution',
                            config: {
                                operation: '',
                                maxConcurrency: 5
                            }
                        }
                    ],
                    "Quality": [
                        {
                            type: 'Self-Review',
                            label: 'Self-Review',
                            icon: '‚úÖ',
                            color: '#06b6d4',
                            description: 'Quality validation',
                            config: {
                                checkCompleteness: true,
                                checkAccuracy: true,
                                checkTone: false,
                                confidenceThreshold: 0.8,
                                maxIterations: 3
                            }
                        },
                        {
                            type: 'HITL',
                            label: 'Human Review',
                            icon: 'üë§',
                            color: '#06b6d4',
                            description: 'Human approval gate',
                            config: {
                                title: '',
                                message: '',
                                priority: 'medium',
                                allowEdit: true,
                                allowDefer: false
                            }
                        }
                    ],
                    "Integration": [
                        {
                            type: 'API',
                            label: 'API Request',
                            icon: 'üåê',
                            color: '#3b82f6',
                            description: 'HTTP request',
                            config: {
                                method: 'GET',
                                url: '',
                                headers: {},
                                auth: { type: 'none', value: '', username: '', password: '', token: '', key: '', param_name: 'X-API-Key', location: 'header' }
                            }
                        },
                        {
                            type: 'MCP',
                            label: 'MCP Server',
                            icon: 'üîå',
                            color: '#3b82f6',
                            description: 'Model Context Protocol',
                            config: {
                                serverId: '',
                                customUrl: '',
                                operation: '',
                                command: '',
                                transport_type: 'http',
                                timeout: 120,
                                toolName: '',
                                argumentsRaw: ''
                            }
                        }
                    ],
                    "Code": [
                        {
                            type: 'Code',
                            label: 'Code Execution',
                            icon: 'üíª',
                            color: '#0ea5e9',
                            description: 'Run custom code',
                            config: {
                                language: 'python',
                                code: '',
                                packages: ''
                            }
                        },
                        {
                            type: 'Template',
                            label: 'Template',
                            icon: 'üìù',
                            color: '#0ea5e9',
                            description: 'String templating',
                            config: {
                                template: '',
                                engine: 'jinja2'
                            }
                        }
                    ],
                    "Resilience": [
                        {
                            type: 'Failsafe',
                            label: 'Failsafe',
                            icon: 'üõ°Ô∏è',
                            color: '#ef4444',
                            description: 'Error handling',
                            config: {
                                retryAttempts: 3,
                                timeout: 30
                            }
                        }
                    ],
                    "Utility": [
                        {
                            type: 'Merge',
                            label: 'Merge',
                            icon: '‚ö°',
                            color: '#14b8a6',
                            description: 'Combine branches',
                            config: {
                                strategy: 'wait_all'
                            }
                        }
                    ]
                };

                const filteredLibrary = computed(() => {
                    if (!searchQuery.value) return nodeLibrary;

                    const query = searchQuery.value.toLowerCase();
                    const filtered = {};

                    Object.keys(nodeLibrary).forEach(category => {
                        const nodes = nodeLibrary[category].filter(node =>
                            node.label.toLowerCase().includes(query) ||
                            node.type.toLowerCase().includes(query) ||
                            node.description.toLowerCase().includes(query)
                        );
                        if (nodes.length > 0) {
                            filtered[category] = nodes;
                        }
                    });

                    return filtered;
                });

                const filteredAgentTemplates = computed(() => {
                    if (!agentSearchQuery.value) return agentTemplates;

                    const query = agentSearchQuery.value.toLowerCase();
                    return agentTemplates.filter(agent =>
                        agent.name.toLowerCase().includes(query) ||
                        agent.description.toLowerCase().includes(query) ||
                        agent.tools.some(tool => tool.toLowerCase().includes(query))
                    );
                });

                // Filter out tools already added to the selected agent
                const availableTools = computed(() => {
                    if (!selected.value || !selected.value.config || !selected.value.config.tools) {
                        return registeredTools.value;
                    }

                    // Get IDs/names of tools already added to this agent
                    const addedToolIds = new Set(
                        selected.value.config.tools.map(t => t.tool_id || t.id || t.name)
                    );

                    // Filter out already-added tools
                    return registeredTools.value.filter(tool =>
                        !addedToolIds.has(tool.tool_id) &&
                        !addedToolIds.has(tool.name)
                    );
                });

                const addNode = (nodeTemplate) => {
                    const newNode = {
                        ...JSON.parse(JSON.stringify(nodeTemplate)),
                        id: Date.now(),
                        x: 300 + Math.random() * 100,
                        y: 200 + Math.random() * 100,
                        name: nodeTemplate.label,
                        status: 'idle'
                    };
                    activeNodes.value.push(newNode);
                    selected.value = newNode;
                    markWorkflowModified();
                };

                const addAgentFromTemplate = (template) => {
                    const agentNode = {
                        type: 'Agent',
                        label: template.name,
                        icon: template.icon,
                        color: '#f59e0b',
                        id: Date.now(),
                        x: 300 + Math.random() * 100,
                        y: 200 + Math.random() * 100,
                        name: template.name,
                        status: 'idle',
                        config: {
                            prompt: template.prompt,
                            model: {
                                provider: 'anthropic',
                                modelName: 'claude-sonnet-4-5-20250514',
                                displayName: 'Claude Sonnet 4.5'
                            },
                            tools: Array.isArray(template.tools) ? template.tools.map((toolName, idx) => ({
                                id: Date.now() + idx,
                                tool_id: toolName.toLowerCase().replace(/\s+/g, '_'),
                                name: toolName,
                                type: 'tools',
                                enabled: true,
                                config: {
                                    provider: '',
                                    action: '',
                                    credentials: '',
                                    description: ''
                                }
                            })) : [],
                            maxIterations: 5,
                            variables: JSON.parse(JSON.stringify(template.variables)),
                            routing: {
                                strategy: 'llm-driven',
                                routes: []
                            },
                            temperature: 0.7,
                            topP: 0.9,
                            maxTokens: 4000,
                            memory: {
                                enabled: true,
                                type: 'short-term'
                            },
                            adornments: []
                        }
                    };

                    activeNodes.value.push(agentNode);
                    selected.value = agentNode;
                    markWorkflowModified();
                };

                const startDrag = (node, e) => {
                    dragNode.value = node;
                    offset.x = e.clientX / zoomLevel.value - node.x;
                    offset.y = e.clientY / zoomLevel.value - node.y;
                    selected.value = node;
                    e.stopPropagation();
                };

                const handleCanvasMouseMove = (e) => {
                    if (dragNode.value) {
                        dragNode.value.x = e.clientX / zoomLevel.value - offset.x;
                        dragNode.value.y = e.clientY / zoomLevel.value - offset.y;
                    }
                };

                const handleCanvasMouseUp = (e) => {
                    dragNode.value = null;
                };

                const handleCanvasClick = (e) => {
                    if (e.target.classList.contains('canvas-grid') || e.target.classList.contains('canvas-content')) {
                        selected.value = null;
                    }
                };

                const selectNode = (node) => {
                    selected.value = node;
                    activeTab.value = 'overview';
                    showToolDropdown.value = false;

                    // Initialize missing auth fields for API nodes (backward compat)
                    if (node.type === 'API' && node.config && node.config.auth) {
                        const auth = node.config.auth;
                        if (auth.username === undefined) auth.username = '';
                        if (auth.password === undefined) auth.password = '';
                        if (auth.token === undefined) auth.token = '';
                        if (auth.key === undefined) auth.key = '';
                        if (auth.param_name === undefined) auth.param_name = 'X-API-Key';
                        if (auth.location === undefined) auth.location = 'header';
                    }

                    // Initialize missing properties for Agent, Prompt, Subagent nodes
                    if (['Agent', 'Prompt', 'Subagent'].includes(node.type)) {
                        if (!node.config.variables) node.config.variables = [];
                        if (!node.config.adornments) node.config.adornments = [];
                        if (node.config.topP === undefined) node.config.topP = 0.9;
                        if (!node.config.tools) node.config.tools = [];
                        if (!node.config.routing) node.config.routing = { strategy: 'llm-driven', routes: [] };
                        if (!node.config.memory) node.config.memory = { enabled: true, type: 'short-term' };
                    }
                };

                const deleteNode = () => {
                    if (selected.value) {
                        activeNodes.value = activeNodes.value.filter(n => n.id !== selected.value.id);
                        connections.value = connections.value.filter(
                            c => c.from !== selected.value.id && c.to !== selected.value.id
                        );
                        selected.value = null;
                        markWorkflowModified();
                    }
                };

                const deleteConnection = (connectionId) => {
                    connections.value = connections.value.filter(c => c.id !== connectionId);
                    markWorkflowModified();
                };

                const updateModelDisplay = () => {
                    if (selected.value && selected.value.config.model) {
                        const modelNames = {
                            "openrouter-model": 'Open Router',
                            'claude-sonnet-4-5-20250514': 'Claude Sonnet 4.5',
                            'claude-opus-4-20250514': 'Claude Opus 4',
                            'claude-haiku-4-5-20251001': 'Claude Haiku 4.5',
                            'gpt-4-turbo': 'GPT-4 Turbo',
                            'gpt-4o': 'GPT-4o',
                            'gpt-3.5-turbo': 'GPT-3.5 Turbo',
                            'gemini-pro': 'Gemini Pro',
                            'gemini-ultra': 'Gemini Ultra'
                        };
                        selected.value.config.model.displayName = modelNames[selected.value.config.model.modelName] || selected.value.config.model.modelName;
                    }
                };

                const link = (node, mode) => {
                    if (mode === 'out') {
                        linkSource.value = node;
                    } else if (mode === 'in' && linkSource.value) {
                        connections.value.push({
                            id: Date.now(),
                            from: linkSource.value.id,
                            to: node.id
                        });
                        linkSource.value = null;
                    }
                };

                const getConnectionPath = (conn) => {
                    const fromNode = activeNodes.value.find(n => n.id === conn.from);
                    const toNode = activeNodes.value.find(n => n.id === conn.to);
                    if (!fromNode || !toNode) return '';

                    const x1 = fromNode.x + 240;
                    const y1 = fromNode.y + 40;
                    const x2 = toNode.x;
                    const y2 = toNode.y + 40;

                    const dx = x2 - x1;
                    const controlOffset = Math.min(Math.abs(dx) / 2, 100);

                    return `M ${x1} ${y1} C ${x1 + controlOffset} ${y1}, ${x2 - controlOffset} ${y2}, ${x2} ${y2}`;
                };

                const zoomIn = () => {
                    if (zoomLevel.value < 2) {
                        zoomLevel.value = Math.min(2, zoomLevel.value + 0.1);
                    }
                };

                const zoomOut = () => {
                    if (zoomLevel.value > 0.3) {
                        zoomLevel.value = Math.max(0.3, zoomLevel.value - 0.1);
                    }
                };

                const resetZoom = () => {
                    zoomLevel.value = 1;
                };

                const exportWorkflow = () => {
                    const workflow = {
                        version: '1.0',
                        name: workflowName.value || 'Untitled Workflow',
                        execution_model: workflowExecutionModel.value,
                        nodes: activeNodes.value,
                        connections: connections.value,
                        metadata: {
                            exported: new Date().toISOString(),
                            nodeCount: activeNodes.value.length,
                            connectionCount: connections.value.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `workflow-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                const importWorkflow = () => {
                    fileInput.value.click();
                };

                const handleFileImport = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const workflow = JSON.parse(event.target.result);

                            // Detect backend/draft format (has 'agents' array instead of 'nodes')
                            if (workflow.agents && Array.isArray(workflow.agents) && !workflow.nodes) {
                                // Backend format - use backendToCanvas API to convert
                                try {
                                    // Build agents map keyed by agent_id
                                    const agentsMap = {};
                                    workflow.agents.forEach(agent => {
                                        agentsMap[agent.agent_id] = agent;
                                    });

                                    const canvasResult = await workflowAPI.backendToCanvas(workflow, agentsMap);
                                    const canvasNodes = canvasResult.canvas_nodes || canvasResult.nodes || [];
                                    const canvasConnections = canvasResult.connections || canvasResult.canvas_connections || [];

                                    activeNodes.value = canvasNodes;
                                    connections.value = canvasConnections;
                                    workflowName.value = workflow.name || 'Imported Workflow';
                                    workflowExecutionModel.value = workflow.execution_model || 'sequential';
                                } catch (apiError) {
                                    console.error('Backend-to-canvas conversion failed:', apiError);
                                    alert('Error importing workflow: Could not convert backend format. Make sure the backend server is running.');
                                    return;
                                }
                            } else {
                                // IDE export format - load directly
                                activeNodes.value = workflow.nodes || [];
                                connections.value = workflow.connections || [];
                                workflowName.value = workflow.name || 'Imported Workflow';
                                workflowExecutionModel.value = workflow.execution_model || 'sequential';
                            }

                            selected.value = null;
                            markWorkflowModified();
                            workflowSaved.value = false;
                            workflowState.value = 'unsaved';
                            currentWorkflowId.value = null;
                            currentThreadId.value = null;
                        } catch (error) {
                            alert('Error importing workflow: Invalid JSON file');
                        }
                    };
                    reader.readAsText(file);
                    e.target.value = '';
                };

                const clearCanvas = () => {
                    if (activeNodes.value.length === 0) return;

                    if (confirm('Are you sure you want to clear the entire canvas? This cannot be undone.')) {
                        activeNodes.value = [];
                        connections.value = [];
                        selected.value = null;
                        markWorkflowModified();
                        workflowState.value = 'empty';
                        currentWorkflowId.value = null;
                        currentThreadId.value = null;
                        workflowSaved.value = false;
                    }
                };

                const addInputVariable = () => {
                    if (selected.value && selected.value.config.inputVariables) {
                        selected.value.config.inputVariables.push({
                            name: '',
                            type: 'string',
                            required: false,
                            description: ''
                        });
                    }
                };

                const addOutputVariable = () => {
                    if (selected.value && selected.value.config.outputVariables) {
                        selected.value.config.outputVariables.push({
                            name: '',
                            type: 'string'
                        });
                    }
                };

                // Add builtin tool type (code, subworkflow, mcp_server, etc.)
                const addBuiltinTool = (toolType) => {
                    if (selected.value && selected.value.config.tools) {
                        const toolNames = {
                            'code': 'Code Execution',
                            'subworkflow': 'Subworkflow',
                            'subworkflow_deployment': 'Subworkflow Deployment',
                            'mcp_server': 'MCP Server'
                        };
                        const defaultConfigs = {
                            'code': { language: 'python', code: '' },
                            'subworkflow': { workflowId: '' },
                            'subworkflow_deployment': { deploymentId: '', environment: 'production' },
                            'mcp_server': { serverId: '', operationName: '' }
                        };
                        selected.value.config.tools.push({
                            id: Date.now(),
                            name: toolNames[toolType],
                            type: toolType,
                            enabled: true,
                            config: defaultConfigs[toolType] || {}
                        });
                    }
                    showToolDropdown.value = false;
                };

                // Add registered tool from backend
                const addTool = (tool) => {
                    if (selected.value && selected.value.config.tools) {
                        selected.value.config.tools.push({
                            id: Date.now(),
                            tool_id: tool.tool_id,
                            name: tool.name,
                            type: tool.tool_type,
                            description: tool.description,
                            enabled: true,
                            version: tool.version,
                            tags: tool.tags || [],
                            config: tool.input_schema || {}
                        });
                    }
                    showToolDropdown.value = false;
                };

                const removeTool = (index) => {
                    if (selected.value && selected.value.config.tools) {
                        selected.value.config.tools.splice(index, 1);
                    }
                };

                const openToolConfig = (index) => {
                    if (selected.value && selected.value.config.tools[index]) {
                        const tool = JSON.parse(JSON.stringify(selected.value.config.tools[index]));
                        // Ensure config object exists for v-model bindings
                        if (!tool.config) tool.config = {};
                        toolConfigModal.value = {
                            show: true,
                            tool: tool,
                            toolIndex: index
                        };
                    }
                };

                const closeToolConfig = () => {
                    toolConfigModal.value = {
                        show: false,
                        tool: null,
                        toolIndex: null
                    };
                };

                const saveToolConfig = () => {
                    if (selected.value && toolConfigModal.value.toolIndex !== null) {
                        selected.value.config.tools[toolConfigModal.value.toolIndex] = toolConfigModal.value.tool;
                    }
                    closeToolConfig();
                };

                const getToolIcon = (toolType) => {
                    const icons = {
                        // Backend tool types
                        'local': 'üîß',
                        'mcp': 'üîå',
                        'api': 'üåê',
                        'crewai': 'ü§ñ',
                        // Legacy types (for backward compatibility)
                        'tools': 'üß©',
                        'code': 'üíª',
                        'subworkflow': 'üîÄ',
                        'subworkflow_deployment': 'üí†',
                        'mcp_server': 'üîå'
                    };
                    return icons[toolType] || 'üîß';
                };

                const addRoute = () => {
                    if (selected.value && selected.value.config.routing) {
                        selected.value.config.routing.routes.push({
                            condition: '',
                            targetNodeId: ''
                        });
                    }
                };

                const addBranch = () => {
                    if (selected.value && selected.value.config.branches) {
                        const lastIndex = selected.value.config.branches.length - 1;
                        selected.value.config.branches.splice(lastIndex, 0, {
                            condition: '',
                            targetNodeId: ''
                        });
                    }
                };

                const addAgentVariable = () => {
                    if (selected.value) {
                        if (!selected.value.config.variables) {
                            selected.value.config.variables = [];
                        }
                        selected.value.config.variables.push({
                            name: '',
                            type: 'string',
                            defaultValue: ''
                        });
                    }
                };

                const addAdornment = () => {
                    if (selected.value) {
                        if (!selected.value.config.adornments) {
                            selected.value.config.adornments = [];
                        }
                        selected.value.config.adornments.push({
                            type: 'retry',
                            maxAttempts: 3,
                            backoffStrategy: 'exponential',
                            delay: 1000,
                            timeout: 30,
                            enabled: true,
                            fallbackAction: 'default_value',
                            onError: 'continue'
                        });
                    }
                };

                const getConnectedAgents = (nodeId) => {
                    const outgoingConnections = connections.value.filter(c => c.from === nodeId);
                    return outgoingConnections
                        .map(conn => activeNodes.value.find(n => n.id === conn.to))
                        .filter(node => node && (node.type === 'Agent' || node.type === 'Subagent'));
                };

                // Prompt Pane Resizing
                const startResize = (e) => {
                    isResizing.value = true;
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                    e.preventDefault();
                };

                const handleResize = (e) => {
                    if (isResizing.value) {
                        const newWidth = e.clientX;
                        if (newWidth >= 300 && newWidth <= 600) {
                            promptPaneWidth.value = newWidth;
                        }
                    }
                };

                const stopResize = () => {
                    isResizing.value = false;
                    document.removeEventListener('mousemove', handleResize);
                    document.removeEventListener('mouseup', stopResize);
                };

                // Workflow Generation - Call Backend API with fallback
                const generateWorkflow = async () => {
                    if (!workflowPrompt.value.trim() || isGenerating.value) return;

                    if (activeNodes.value.length > 0) {
                        // Show modal dialog for user choice
                        showWorkflowDialog.value = true;
                        pendingWorkflowGeneration.value = true;
                        return; // Wait for user choice in modal
                    }

                    // Proceed with generation
                    await proceedWithGeneration(false); // false = don't append
                };

                const proceedWithGeneration = async (appendMode = false) => {
                    isGenerating.value = true;
                    generationStatus.value = 'Analyzing prompt with AI...';

                    try {
                        // Try backend API first
                        const result = await workflowAPI.designFromPrompt(workflowPrompt.value.trim());
                        generationStatus.value = 'Creating workflow from AI design...';

                        const workflow = result.workflow;
                        const agents = result.agents;

                        // Convert backend response to canvas format
                        const createdNodes = [];
                        const newConnections = [];
                        const spacing = 280;

                        // For append mode, find existing End node and calculate position
                        let existingEndNode = null;
                        let lastAgentBeforeEnd = null;
                        let connectionToEndIndex = -1;
                        let x = 100;
                        let y = 100;

                        if (appendMode) {
                            // Find existing End node
                            existingEndNode = activeNodes.value.find(n => n.type === 'End');
                            if (!existingEndNode) {
                                console.warn('No End node found on canvas, falling back to normal generation');
                                appendMode = false;
                            } else {
                                // Find connection going to End node
                                connectionToEndIndex = connections.value.findIndex(c => c.to === existingEndNode.id);
                                if (connectionToEndIndex !== -1) {
                                    const lastAgentId = connections.value[connectionToEndIndex].from;
                                    lastAgentBeforeEnd = activeNodes.value.find(n => n.id === lastAgentId);
                                }

                                // Calculate position: start after the last agent (before End)
                                if (lastAgentBeforeEnd) {
                                    x = lastAgentBeforeEnd.x + spacing;
                                    y = lastAgentBeforeEnd.y;
                                } else {
                                    // Fallback: position based on End node
                                    x = existingEndNode.x;
                                    y = existingEndNode.y;
                                }
                            }
                        }

                        let startNode = null;
                        if (!appendMode) {
                            // Add Start node only when NOT appending
                            startNode = {
                                ...JSON.parse(JSON.stringify(nodeLibrary['Entry/Exit'][0])),
                                id: Date.now(),
                                x: x,
                                y: y,
                                name: 'Workflow Start',
                                status: 'idle'
                            };
                            createdNodes.push(startNode);
                            x += spacing;
                        }

                        // Add agent nodes from backend response
                        const agentIds = workflow.agents || [];
                        let nodeIdMap = {};

                        for (let i = 0; i < agentIds.length; i++) {
                            const agentId = agentIds[i];
                            const agentData = agents[agentId] || {};

                            const agentNode = {
                                type: 'Agent',
                                label: agentData.name || 'Agent',
                                icon: agentData.icon || 'üî∂',
                                color: '#f59e0b',
                                id: Date.now() + i + 1,
                                x: x,
                                y: y,
                                name: agentData.name || `Agent ${i + 1}`,
                                status: 'idle',
                                agentId: agentId,
                                config: {
                                    prompt: agentData.description || '',
                                    model: {
                                        // Use backend LLMManager defaults - don't hardcode provider/model
                                        provider: agentData.llm?.provider || '',  // Empty = backend default
                                        modelName: agentData.llm?.model || '',     // Empty = backend default
                                        displayName: 'LLM Manager Default'
                                    },
                                    // Convert tool IDs (strings) from backend to frontend tool objects
                                    tools: Array.isArray(agentData.tools) ? agentData.tools.map((tool, idx) => {
                                        // If already an object, preserve it
                                        if (typeof tool === 'object' && tool !== null) {
                                            return {
                                                id: tool.id || Date.now() + idx,
                                                tool_id: tool.tool_id || tool.name?.toLowerCase().replace(/\s+/g, '_') || '',
                                                name: tool.name || 'Unknown Tool',
                                                type: tool.type || 'tools',
                                                enabled: tool.enabled !== false,
                                                config: tool.config || {}
                                            };
                                        }
                                        // If string (tool ID), look up from registered tools
                                        const registeredTool = registeredTools.value.find(t => t.tool_id === tool);
                                        if (registeredTool) {
                                            return {
                                                id: Date.now() + idx,
                                                tool_id: tool,
                                                name: registeredTool.name,
                                                type: registeredTool.tool_type || 'local',
                                                description: registeredTool.description || '',
                                                enabled: true,
                                                config: {}
                                            };
                                        }
                                        // Fallback for unknown tools
                                        return {
                                            id: Date.now() + idx,
                                            tool_id: tool,
                                            name: tool.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                                            type: 'tools',
                                            enabled: true,
                                            config: {}
                                        };
                                    }) : [],
                                    maxIterations: agentData.constraints?.max_steps || 5,
                                    variables: agentData.variables || [],
                                    routing: { strategy: 'llm-driven', routes: [] },
                                    temperature: agentData.llm?.temperature || 0.7,
                                    topP: 0.9,
                                    maxTokens: 4000,
                                    memory: { enabled: true, type: 'short-term' },
                                    adornments: []
                                }
                            };

                            createdNodes.push(agentNode);
                            nodeIdMap[agentId] = agentNode.id;
                            x += spacing;
                        }

                        let endNode = null;
                        if (!appendMode) {
                            // Add End node only when NOT appending
                            endNode = {
                                ...JSON.parse(JSON.stringify(nodeLibrary['Entry/Exit'][1])),
                                id: Date.now() + 100,
                                x: x,
                                y: y,
                                name: 'Workflow End',
                                status: 'idle'
                            };
                            createdNodes.push(endNode);
                        }

                        // Create connections
                        if (appendMode && existingEndNode && createdNodes.length > 0) {
                            // APPEND MODE: Insert new agents before existing End node

                            // Remove old connection to End node
                            if (connectionToEndIndex !== -1) {
                                connections.value.splice(connectionToEndIndex, 1);
                            }

                            // Connect last existing agent to first new agent
                            if (lastAgentBeforeEnd) {
                                newConnections.push({
                                    id: Date.now() + 1000,
                                    from: lastAgentBeforeEnd.id,
                                    to: createdNodes[0].id
                                });
                            }

                            // Connect new agents sequentially
                            for (let i = 0; i < createdNodes.length - 1; i++) {
                                newConnections.push({
                                    id: Date.now() + 1001 + i,
                                    from: createdNodes[i].id,
                                    to: createdNodes[i + 1].id
                                });
                            }

                            // Connect last new agent to existing End node
                            newConnections.push({
                                id: Date.now() + 2000,
                                from: createdNodes[createdNodes.length - 1].id,
                                to: existingEndNode.id
                            });

                            // Move existing End node to new position
                            existingEndNode.x = x;
                            existingEndNode.y = y;

                        } else {
                            // NORMAL MODE: Create full workflow with Start/End
                            const workflowConnections = workflow.connections || [];

                            if (workflowConnections.length > 0) {
                                // Use defined connections
                                for (let conn of workflowConnections) {
                                    const fromId = nodeIdMap[conn.from];
                                    const toId = nodeIdMap[conn.to];
                                    if (fromId && toId) {
                                        newConnections.push({
                                            id: Date.now() + 1000 + newConnections.length,
                                            from: fromId,
                                            to: toId
                                        });
                                    }
                                }
                                // Connect start to first agent
                                if (createdNodes.length > 2) {
                                    newConnections.unshift({
                                        id: Date.now() + 2000,
                                        from: startNode.id,
                                        to: createdNodes[1].id
                                    });
                                }
                                // Connect last agent to end
                                if (createdNodes.length > 2) {
                                    newConnections.push({
                                        id: Date.now() + 3000,
                                        from: createdNodes[createdNodes.length - 2].id,
                                        to: endNode.id
                                    });
                                }
                            } else if (workflow.execution_model === 'parallel' && createdNodes.length > 2) {
                                // Parallel connections: start ‚Üí [all agents] ‚Üí end
                                const agentNodes = createdNodes.slice(1, -1);
                                for (let i = 0; i < agentNodes.length; i++) {
                                    // Start ‚Üí each agent
                                    newConnections.push({
                                        id: Date.now() + 1000 + i,
                                        from: startNode.id,
                                        to: agentNodes[i].id
                                    });
                                    // Each agent ‚Üí end
                                    newConnections.push({
                                        id: Date.now() + 2000 + i,
                                        from: agentNodes[i].id,
                                        to: endNode.id
                                    });
                                }
                                // Layout agents vertically for parallel visual
                                const baseY = 100;
                                const ySpacing = 150;
                                startNode.x = 100;
                                startNode.y = baseY + (agentNodes.length - 1) * ySpacing / 2;
                                endNode.x = 100 + spacing * 2;
                                endNode.y = startNode.y;
                                for (let i = 0; i < agentNodes.length; i++) {
                                    agentNodes[i].x = 100 + spacing;
                                    agentNodes[i].y = baseY + i * ySpacing;
                                }
                            } else {
                                // Sequential connections (fallback)
                                for (let i = 0; i < createdNodes.length - 1; i++) {
                                    newConnections.push({
                                        id: Date.now() + 1000 + i,
                                        from: createdNodes[i].id,
                                        to: createdNodes[i + 1].id
                                    });
                                }
                            }
                        }

                        // Set workflow name and execution model from LLM response (only for new workflows)
                        if (!appendMode) {
                            workflowName.value = workflow.name || 'AI Generated Workflow';
                            workflowExecutionModel.value = workflow.execution_model || 'sequential';
                            currentWorkflowId.value = null;
                            currentThreadId.value = null;
                        }

                        // Add to canvas
                        activeNodes.value.push(...createdNodes);
                        connections.value.push(...newConnections);
                        workflowSaved.value = false;
                        workflowModified.value = true;
                        workflowState.value = 'unsaved';

                        // Add to history
                        generatedWorkflows.value.unshift({
                            title: appendMode ? `Appended: ${workflow.name || 'agents'}` : (workflow.name || workflowPrompt.value.substring(0, 50) + '...'),
                            nodeCount: createdNodes.length,
                            agentCount: agentIds.length,
                            executionModel: workflow.execution_model || 'sequential',
                            timestamp: new Date().toLocaleTimeString()
                        });

                        generationStatus.value = appendMode ? 'Agents appended successfully!' : 'Workflow created successfully!';

                    } catch (apiError) {
                        console.warn('Backend API unavailable, using local generation:', apiError.message);
                        generationStatus.value = 'Using local generation (backend unavailable)...';

                        // Fallback to local keyword-based generation (doesn't support append mode)
                        await generateWorkflowLocal();
                    }

                    setTimeout(() => {
                        isGenerating.value = false;
                        generationStatus.value = '';
                        workflowPrompt.value = '';
                    }, 1500);
                };

                // Local fallback workflow generation
                const generateWorkflowLocal = async () => {
                    const prompt = workflowPrompt.value.toLowerCase();
                    let x = 100;
                    let y = 100;
                    const spacing = 250;
                    const createdNodes = [];

                    // Start node
                    const startNode = {
                        ...JSON.parse(JSON.stringify(nodeLibrary['Entry/Exit'][0])),
                        id: Date.now(),
                        x: x,
                        y: y,
                        name: 'Workflow Start',
                        status: 'idle'
                    };
                    createdNodes.push(startNode);
                    x += spacing;

                    // Detect and add relevant nodes based on keywords
                    if (prompt.includes('slack') || prompt.includes('message')) {
                        const node = {
                            ...JSON.parse(JSON.stringify(nodeLibrary['Integration'][0])),
                            id: Date.now() + 1,
                            x: x,
                            y: y,
                            name: 'Slack Integration',
                            status: 'idle'
                        };
                        createdNodes.push(node);
                        x += spacing;
                    }

                    if (prompt.includes('ai') || prompt.includes('analyze') || prompt.includes('sentiment')) {
                        const node = {
                            ...JSON.parse(JSON.stringify(nodeLibrary['Agents'][0])),
                            id: Date.now() + 2,
                            x: x,
                            y: y,
                            name: 'AI Analyzer',
                            status: 'idle'
                        };
                        createdNodes.push(node);
                        x += spacing;
                    }

                    if (prompt.includes('human') || prompt.includes('escalate') || prompt.includes('approval')) {
                        const node = {
                            ...JSON.parse(JSON.stringify(nodeLibrary['Quality'][1])),
                            id: Date.now() + 3,
                            x: x,
                            y: y,
                            name: 'Human Review',
                            status: 'idle'
                        };
                        createdNodes.push(node);
                        x += spacing;
                    }

                    if (prompt.includes('database') || prompt.includes('log') || prompt.includes('store')) {
                        const node = {
                            ...JSON.parse(JSON.stringify(nodeLibrary['Integration'][0])),
                            id: Date.now() + 4,
                            x: x,
                            y: y,
                            name: 'Database',
                            status: 'idle'
                        };
                        createdNodes.push(node);
                        x += spacing;
                    }

                    // End node
                    const endNode = {
                        ...JSON.parse(JSON.stringify(nodeLibrary['Entry/Exit'][1])),
                        id: Date.now() + 100,
                        x: x,
                        y: y,
                        name: 'Workflow End',
                        status: 'idle'
                    };
                    createdNodes.push(endNode);

                    // Create connections
                    const newConnections = [];
                    for (let i = 0; i < createdNodes.length - 1; i++) {
                        newConnections.push({
                            id: Date.now() + 1000 + i,
                            from: createdNodes[i].id,
                            to: createdNodes[i + 1].id
                        });
                    }

                    // Add to canvas
                    activeNodes.value.push(...createdNodes);
                    connections.value.push(...newConnections);

                    // Add to history
                    generatedWorkflows.value.unshift({
                        title: workflowPrompt.value.substring(0, 50) + '...',
                        nodeCount: createdNodes.length,
                        timestamp: new Date().toLocaleTimeString()
                    });
                    workflowSaved.value = false;
                    workflowModified.value = true;
                    workflowState.value = 'unsaved';
                    currentWorkflowId.value = null;
                    currentThreadId.value = null;
                };

                // Save workflow to backend
                const saveWorkflow = async (saveAs = 'draft') => {
                    if (activeNodes.value.length === 0) {
                        alert('No workflow to save. Please add nodes first.');
                        return;
                    }

                    saveStatus.value = 'Saving...';

                    try {
                        // Pass existing workflow_id to preserve it across saves
                        const result = await workflowAPI.saveCanvas(
                            activeNodes.value,
                            connections.value,
                            workflowName.value || 'Untitled Workflow',
                            saveAs,
                            workflowExecutionModel.value,
                            currentWorkflowId.value  // Preserve existing ID
                        );

                        if (result.success) {
                            saveStatus.value = `Saved! ID: ${result.workflow_id}`;
                            alert(`Workflow saved successfully!\nID: ${result.workflow_id}\nName: ${result.workflow_name}`);
                            workflowSaved.value = true;
                            workflowModified.value = false;
                            workflowState.value = 'saved';
                            currentWorkflowId.value = result.workflow_id || currentWorkflowId.value;
                            workflowName.value = result.workflow_name || workflowName.value;
                        } else {
                            saveStatus.value = 'Save failed';
                            workflowSaved.value = false;
                            workflowState.value = 'unsaved';
                            alert(`Save failed: ${result.errors?.join(', ') || 'Unknown error'}`);
                        }
                    } catch (error) {
                        saveStatus.value = 'Save failed';
                        workflowSaved.value = false;
                        workflowState.value = 'unsaved';
                        console.error('Save error:', error);
                        alert(`Failed to save workflow: ${error.message}`);
                    }

                    setTimeout(() => {
                        saveStatus.value = '';
                    }, 3000);
                };

                const loadWorkflowDialog = async () => {
                    // Show modal and fetch draft list
                    showLoadModal.value = true;
                    isLoadingDrafts.value = true;
                    manualWorkflowId.value = '';

                    try {
                        const result = await workflowAPI.listDrafts();
                        draftWorkflows.value = result.workflows || [];
                    } catch (error) {
                        console.error('Failed to load draft list:', error);
                        draftWorkflows.value = [];
                    } finally {
                        isLoadingDrafts.value = false;
                    }
                };

                // Load a workflow by ID (reusable helper)
                const loadWorkflowById = async (workflowId) => {
                    try {
                        const result = await workflowAPI.loadWorkflow(workflowId);
                        const workflow = result.workflow || result;
                        const agents = result.agents || result.agent_map || {};
                        const canvasResult = await workflowAPI.backendToCanvas(workflow, agents);
                        const canvasNodes = canvasResult.canvas_nodes || canvasResult.nodes || [];
                        const canvasConnections = canvasResult.connections || canvasResult.canvas_connections || [];

                        activeNodes.value = canvasNodes;
                        connections.value = canvasConnections;
                        workflowName.value = workflow.name || workflowName.value;
                        currentWorkflowId.value = workflowId;
                        workflowSaved.value = true;
                        workflowModified.value = false;
                        workflowState.value = 'saved';
                        currentThreadId.value = null;
                        chatSessionId.value = null;  // Reset chat session for new workflow
                        chatMessages.value = [];     // Clear chat history

                        return true;
                    } catch (error) {
                        console.error('Load workflow error:', error);
                        alert(`Failed to load workflow: ${error.message}`);
                        return false;
                    }
                };

                // Load selected draft from list
                const loadSelectedDraft = async (workflowId) => {
                    showLoadModal.value = false;
                    await loadWorkflowById(workflowId);
                };

                // Load workflow by manually entered ID
                const loadManualId = async () => {
                    const workflowId = manualWorkflowId.value.trim();
                    if (!workflowId) return;

                    showLoadModal.value = false;
                    manualWorkflowId.value = '';
                    await loadWorkflowById(workflowId);
                };

                const runWorkflow = async () => {
                    if (activeNodes.value.length === 0) {
                        alert('No workflow to run. Please add nodes first.');
                        return;
                    }

                    // Always save as 'temp' before running (executor expects temp state)
                    if (!currentWorkflowId.value || !workflowSaved.value) {
                        const shouldSave = confirm('Workflow must be saved before running. Save now?');
                        if (shouldSave) {
                            await saveWorkflow('temp');  // Save as temp for test execution
                        } else {
                            return;
                        }
                    } else {
                        // Re-save as temp to ensure latest changes are captured
                        await saveWorkflow('temp');
                    }

                    if (!currentWorkflowId.value) {
                        alert('Missing workflow ID after save. Please try saving again.');
                        return;
                    }

                    // Show input modal for user to provide payload
                    workflowInput.value = '{"message": ""}';
                    showInputModal.value = true;
                };

                const closeInputModal = () => {
                    showInputModal.value = false;
                };

                const executeWithInput = async () => {
                    let inputPayload = {};

                    // Validate JSON
                    if (workflowInput.value && workflowInput.value.trim()) {
                        try {
                            inputPayload = JSON.parse(workflowInput.value);
                        } catch (error) {
                            alert('Invalid JSON payload. Please provide valid JSON.');
                            return;
                        }
                    }

                    // Close input modal and show execution modal
                    showInputModal.value = false;
                    isExecuting.value = true;
                    showExecutionModal.value = true;
                    executionResult.value = { status: 'running', started_at: new Date().toISOString() };

                    try {
                        const result = await workflowAPI.execute(
                            currentWorkflowId.value,
                            'test',
                            null,
                            inputPayload
                        );
                        executionResult.value = result;
                    } catch (error) {
                        executionResult.value = { success: false, error: error.message };
                        console.error('Run workflow error:', error);
                    } finally {
                        isExecuting.value = false;
                    }
                };

                const closeExecutionModal = () => {
                    showExecutionModal.value = false;
                };

                const closeWorkflowDialog = () => {
                    showWorkflowDialog.value = false;
                    pendingWorkflowGeneration.value = false;
                };

                const handleWorkflowChoice = async (choice) => {
                    showWorkflowDialog.value = false;

                    if (choice === 'save') {
                        // Save current workflow as draft and clear canvas
                        await saveWorkflow('draft');
                        resetCanvasState();
                        await proceedWithGeneration(false);
                    } else if (choice === 'discard') {
                        // Discard current workflow and clear canvas
                        resetCanvasState();
                        await proceedWithGeneration(false);
                    } else if (choice === 'modify') {
                        // Use intelligent NL modification - LLM understands intent
                        await proceedWithModification();
                    } else if (choice === 'append') {
                        // Legacy append - adds new agents from fresh generation
                        await proceedWithGeneration(true);
                    }
                };

                // Intelligent workflow modification using LLM-based intent detection
                const proceedWithModification = async () => {
                    if (!workflowPrompt.value.trim()) {
                        pendingWorkflowGeneration.value = false;
                        return;
                    }

                    isGenerating.value = true;
                    generationStatus.value = 'Analyzing your request with AI...';

                    try {
                        // Build existing workflow structure from canvas
                        const existingWorkflow = buildWorkflowFromCanvas();
                        const existingAgents = buildAgentsFromCanvas();

                        // Build conversation history from chat messages
                        const conversationHistory = chatMessages.value.slice(-10).map(msg => ({
                            role: msg.role,
                            content: msg.content
                        }));

                        // Call the intelligent modification endpoint
                        const result = await workflowAPI.modifyWorkflow(
                            workflowPrompt.value.trim(),
                            existingWorkflow,
                            existingAgents,
                            conversationHistory
                        );

                        generationStatus.value = `Intent detected: ${result.intent}. ${result.reasoning || ''}`;

                        // Handle different intents
                        if (result.intent === 'execute') {
                            // This is an execution request, not modification
                            generationStatus.value = 'This seems like a workflow input. Use the Chat panel to interact with the workflow.';
                            setTimeout(() => {
                                isGenerating.value = false;
                                generationStatus.value = '';
                                workflowPrompt.value = '';
                                pendingWorkflowGeneration.value = false;
                            }, 2000);
                            return;
                        }

                        if (result.intent === 'create_new') {
                            // User wants to start fresh
                            generationStatus.value = 'Starting fresh workflow...';
                            resetCanvasState();
                            await proceedWithGeneration(false);
                            return;
                        }

                        if (result.intent === 'clarify') {
                            // LLM needs clarification
                            generationStatus.value = result.message || 'Could you please clarify what you want to do?';
                            setTimeout(() => {
                                isGenerating.value = false;
                                generationStatus.value = '';
                                pendingWorkflowGeneration.value = false;
                            }, 3000);
                            return;
                        }

                        // For actual modifications, apply the changes
                        if (result.success && result.updated_workflow && result.updated_agents) {
                            await applyWorkflowModification(result);
                            generationStatus.value = result.message || 'Workflow modified successfully!';
                        } else {
                            generationStatus.value = result.message || 'Could not apply modification.';
                        }

                        // Add to history
                        generatedWorkflows.value.unshift({
                            title: `Modified: ${result.intent}`,
                            nodeCount: activeNodes.value.length,
                            timestamp: new Date().toLocaleTimeString()
                        });

                    } catch (error) {
                        console.error('Workflow modification error:', error);
                        generationStatus.value = `Error: ${error.message}. Falling back to append mode...`;
                        // Fallback to legacy append behavior
                        await proceedWithGeneration(true);
                    }

                    setTimeout(() => {
                        isGenerating.value = false;
                        generationStatus.value = '';
                        workflowPrompt.value = '';
                        pendingWorkflowGeneration.value = false;
                    }, 1500);
                };

                // Build workflow object from current canvas state
                const buildWorkflowFromCanvas = () => {
                    const agentNodes = activeNodes.value.filter(n => n.type === 'Agent' || n.type === 'Subagent');
                    const agentIds = agentNodes.map(n => n.agentId || n.id.toString());

                    return {
                        workflow_id: currentWorkflowId.value || 'temp_workflow',
                        name: workflowName.value || 'Untitled Workflow',
                        execution_model: workflowExecutionModel.value || 'sequential',
                        agents: agentIds,
                        connections: connections.value.map(c => ({
                            from: c.from.toString(),
                            to: c.to.toString()
                        }))
                    };
                };

                // Build agents dict from current canvas state
                const buildAgentsFromCanvas = () => {
                    const agents = {};
                    const agentNodes = activeNodes.value.filter(n => n.type === 'Agent' || n.type === 'Subagent');

                    for (const node of agentNodes) {
                        const agentId = node.agentId || node.id.toString();
                        agents[agentId] = {
                            agent_id: agentId,
                            name: node.name || node.label || 'Agent',
                            role: node.config?.role || 'Processing',
                            goal: node.config?.goal || '',
                            description: node.config?.prompt || node.config?.description || '',
                            tools: (node.config?.tools || []).map(t => typeof t === 'string' ? t : t.tool_id),
                            llm: {
                                provider: node.config?.model?.provider || '',
                                model: node.config?.model?.modelName || '',
                                temperature: node.config?.temperature || 0.7
                            }
                        };
                    }

                    return agents;
                };

                // Apply modification result to canvas
                // Backend now handles Start/End nodes automatically via map_backend_to_frontend
                const applyWorkflowModification = async (result) => {
                    const updatedWorkflow = result.updated_workflow;
                    const updatedAgents = result.updated_agents;

                    if (!updatedWorkflow || !updatedAgents) return;

                    try {
                        // Convert backend format to canvas format
                        // Backend automatically includes Start/End nodes
                        const canvasResult = await workflowAPI.backendToCanvas(updatedWorkflow, updatedAgents);
                        const canvasNodes = canvasResult.canvas_nodes || canvasResult.nodes || [];
                        const canvasConnections = canvasResult.connections || canvasResult.canvas_connections || [];

                        // Update canvas
                        activeNodes.value = canvasNodes;
                        connections.value = canvasConnections;

                        // Update workflow metadata
                        workflowName.value = updatedWorkflow.name || workflowName.value;
                        workflowExecutionModel.value = updatedWorkflow.execution_model || workflowExecutionModel.value;

                        // Mark as modified
                        workflowSaved.value = false;
                        workflowModified.value = true;
                        workflowState.value = 'unsaved';

                    } catch (error) {
                        console.error('Failed to apply modification to canvas:', error);
                        throw error;
                    }
                };

                const sendChatMessage = async () => {
                    const message = chatInput.value.trim();
                    if (!message || isSendingMessage.value) return;

                    if (activeNodes.value.length === 0) {
                        alert('No workflow on canvas. Please create a workflow first.');
                        return;
                    }

                    // Check if workflow needs to be saved first
                    if (!workflowSaved.value || !currentWorkflowId.value) {
                        const shouldSave = confirm('Workflow must be saved before chatting. Save now?');
                        if (shouldSave) {
                            await saveWorkflow('draft');  // Save as draft (NOT temp)
                            if (!currentWorkflowId.value) {
                                alert('Failed to save workflow. Please try again.');
                                return;
                            }
                        } else {
                            return;
                        }
                    }
                    // NOTE: Do NOT re-save - use the existing draft workflow

                    const userTimestamp = new Date().toLocaleTimeString();
                    chatMessages.value.push({
                        role: 'user',
                        content: message,
                        timestamp: userTimestamp
                    });
                    chatInput.value = '';

                    isSendingMessage.value = true;
                    try {
                        // Start chat session if not already started
                        if (!chatSessionId.value) {
                            const startResponse = await fetch(`${API_BASE_URL}/workflows/chat/start`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    workflow_id: currentWorkflowId.value,
                                    workflow_mode: 'draft',  // Use draft mode for chat
                                    context: {
                                        workflow_name: workflowName.value || 'Untitled Workflow'
                                    }
                                })
                            });

                            if (!startResponse.ok) {
                                throw new Error('Failed to start chat session');
                            }

                            const startData = await startResponse.json();
                            chatSessionId.value = startData.session_id;
                        }

                        // Send message
                        const response = await fetch(`${API_BASE_URL}/workflows/chat/send`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                session_id: chatSessionId.value,
                                message: message,
                                execute_workflow: true
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.detail || 'Chat request failed');
                        }

                        const data = await response.json();

                        // Check if this is an async execution response (has run_id and ws_url)
                        if (data.run_id && data.ws_url && data.status === 'executing') {
                            // Store run_id
                            currentRunId.value = data.run_id;
                            executionSteps.value = [];

                            // Try to connect to WebSocket for real-time updates
                            try {
                                await connectExecutionWebSocket(data.run_id);
                                console.log('[Chat] Connected to execution WebSocket, waiting for events...');
                                // WebSocket will handle the rest - events will update chatMessages
                                // Keep isSendingMessage true until run_completed event
                                return;
                            } catch (wsError) {
                                console.warn('[Chat] WebSocket connection failed, falling back to polling:', wsError.message);
                                // Fall back to polling for result
                                await pollForExecutionResult(data.run_id);
                            }
                        } else {
                            // Legacy response format (synchronous)
                            let botMessage = data.response || data.message || JSON.stringify(data);

                            // If response looks like a Python dict string, extract the meaningful content
                            if (typeof botMessage === 'string' && botMessage.startsWith("{'")) {
                                try {
                                    // Convert Python dict syntax to JSON
                                    const jsonStr = botMessage
                                        .replace(/'/g, '"')
                                        .replace(/True/g, 'true')
                                        .replace(/False/g, 'false')
                                        .replace(/None/g, 'null');

                                    const parsed = JSON.parse(jsonStr);
                                    // Prefer full output fields over preview/truncated versions
                                    botMessage = parsed.final_output || parsed.output || parsed.result || parsed.message || parsed.output_preview || botMessage;
                                } catch (e) {
                                    // If JSON parsing fails, try regex extraction - prefer full output fields
                                    let match = botMessage.match(/["']?(?:final_output|output|result)["']?\s*:\s*["'](.+?)["']\s*[,}]/s);
                                    if (!match) {
                                        match = botMessage.match(/output_preview["']?\s*:\s*["'](.+?)["']\s*,\s*["']?timestamp/);
                                    }
                                    if (match) {
                                        botMessage = match[1].replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/\\n/g, '\n');
                                    }
                                }
                            }

                            const assistantTimestamp = new Date().toLocaleTimeString();
                            chatMessages.value.push({
                                role: 'assistant',
                                content: botMessage,
                                timestamp: assistantTimestamp
                            });
                            isSendingMessage.value = false;
                        }

                    } catch (error) {
                        const assistantTimestamp = new Date().toLocaleTimeString();
                        chatMessages.value.push({
                            role: 'assistant',
                            content: `Error: ${error.message}`,
                            timestamp: assistantTimestamp,
                            error: true
                        });
                        console.error('Chat error:', error);
                        isSendingMessage.value = false;
                    }
                };

                // Polling fallback for execution result (when WebSocket fails)
                const pollForExecutionResult = async (runId) => {
                    const maxAttempts = 60;  // 60 seconds max
                    const pollInterval = 1000;  // 1 second

                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        try {
                            const response = await fetch(`${API_BASE_URL}/workflows/execution/${runId}/steps`);
                            if (response.ok) {
                                const data = await response.json();

                                // Update execution steps
                                if (data.steps && data.steps.length > 0) {
                                    executionSteps.value = data.steps;
                                }

                                // Check if completed
                                if (data.completed_at) {
                                    // Get final response from session
                                    const sessionResponse = await fetch(`${API_BASE_URL}/workflows/chat/history?session_id=${chatSessionId.value}`);
                                    if (sessionResponse.ok) {
                                        const sessionData = await sessionResponse.json();
                                        const lastMessage = sessionData.messages?.slice(-1)[0];
                                        if (lastMessage && lastMessage.role === 'assistant') {
                                            chatMessages.value.push({
                                                role: 'assistant',
                                                content: lastMessage.content,
                                                timestamp: new Date().toLocaleTimeString()
                                            });
                                        }
                                    }
                                    isSendingMessage.value = false;
                                    return;
                                }
                            }
                        } catch (e) {
                            console.warn('[Polling] Error:', e.message);
                        }

                        await new Promise(resolve => setTimeout(resolve, pollInterval));
                    }

                    // Timeout
                    chatMessages.value.push({
                        role: 'assistant',
                        content: 'Execution timed out. Please check the workflow status.',
                        timestamp: new Date().toLocaleTimeString(),
                        error: true
                    });
                    isSendingMessage.value = false;
                };

                // ==================== HITL Review Functions ====================

                const formatHitlSnapshot = (snapshot) => {
                    if (!snapshot) return '';
                    // Show the crew_result (agent output) if available, otherwise show key fields
                    if (snapshot.crew_result) {
                        return snapshot.crew_result;
                    }
                    // Filter out internal fields for display
                    const display = {};
                    for (const [k, v] of Object.entries(snapshot)) {
                        if (!k.startsWith('_') && k !== 'messages' && k !== 'run_id' && k !== 'workflow_id' && v) {
                            display[k] = typeof v === 'string' && v.length > 500
                                ? v.substring(0, 500) + '...'
                                : v;
                        }
                    }
                    return JSON.stringify(display, null, 2);
                };

                const submitHitlDecision = async (action, msg) => {
                    if (hitlSubmitting.value) return;
                    hitlSubmitting.value = true;

                    try {
                        const body = {
                            run_id: msg.hitl.run_id,
                            action: action,
                            actor: 'user',
                        };

                        // For edit action, include the edit content
                        if (action === 'edit') {
                            body.payload = {
                                changes: { edit_feedback: hitlEditContent.value },
                            };
                        }

                        const response = await fetch(`${API_BASE_URL}/workflows/hitl/decide`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body),
                        });

                        if (!response.ok) {
                            const err = await response.json().catch(() => ({}));
                            throw new Error(err.detail || `HTTP ${response.status}`);
                        }

                        const result = await response.json();
                        console.log('[HITL] Decision submitted:', action, result);

                        // Mark the review message as decided
                        msg.decided = action;
                        hitlEditMode.value = false;
                        hitlEditContent.value = '';

                        // Add result message to chat
                        const actionLabels = {
                            approve: '‚úì Approved ‚Äî workflow will resume',
                            reject: '‚úó Rejected ‚Äî workflow terminated',
                            edit: '‚úé Edit submitted ‚Äî workflow will replay',
                            defer: '‚è∏ Deferred ‚Äî workflow paused for later',
                        };
                        chatMessages.value.push({
                            role: 'system',
                            type: 'step_completed',
                            content: actionLabels[action] || `Decision: ${action}`,
                            timestamp: new Date().toLocaleTimeString(),
                        });

                    } catch (error) {
                        console.error('[HITL] Decision failed:', error);
                        chatMessages.value.push({
                            role: 'system',
                            type: 'step_failed',
                            content: `‚ùå HITL decision failed: ${error.message}`,
                            timestamp: new Date().toLocaleTimeString(),
                            error: true,
                        });
                    } finally {
                        hitlSubmitting.value = false;
                    }
                };

                // Load agents from backend on mount
                const loadBackendAgents = async () => {
                    try {
                        const result = await agentAPI.getMasterList();
                        backendAgents.value = result.agents || [];
                        console.log(`Loaded ${backendAgents.value.length} agents from backend`);
                    } catch (error) {
                        console.warn('Could not load agents from backend:', error.message);
                        backendAgents.value = [];
                    }
                };

                // Add agent from backend to canvas
                const addBackendAgent = (agent) => {
                    // Convert tool IDs from backend to frontend tool objects
                    const convertTools = (tools) => {
                        if (!Array.isArray(tools)) return [];
                        return tools.map((tool, idx) => {
                            if (typeof tool === 'object' && tool !== null) {
                                return {
                                    id: tool.id || Date.now() + idx,
                                    tool_id: tool.tool_id || tool.name?.toLowerCase().replace(/\s+/g, '_') || '',
                                    name: tool.name || 'Unknown Tool',
                                    type: tool.type || 'tools',
                                    enabled: tool.enabled !== false,
                                    config: tool.config || {}
                                };
                            }
                            // String tool ID - look up from registered tools
                            const registeredTool = registeredTools.value.find(t => t.tool_id === tool);
                            if (registeredTool) {
                                return {
                                    id: Date.now() + idx,
                                    tool_id: tool,
                                    name: registeredTool.name,
                                    type: registeredTool.tool_type || 'local',
                                    description: registeredTool.description || '',
                                    enabled: true,
                                    config: {}
                                };
                            }
                            // Fallback for unknown tools
                            return {
                                id: Date.now() + idx,
                                tool_id: tool,
                                name: tool.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                                type: 'tools',
                                enabled: true,
                                config: {}
                            };
                        });
                    };

                    const agentNode = {
                        type: 'Agent',
                        label: agent.name,
                        icon: agent.icon || 'ü§ñ',
                        color: '#f59e0b',
                        id: Date.now(),
                        x: 300 + Math.random() * 100,
                        y: 200 + Math.random() * 100,
                        name: agent.name,
                        status: 'idle',
                        agentId: agent.agent_id,
                        config: {
                            prompt: agent.prompt || agent.description || '',
                            goal: agent.goal || '',
                            description: agent.description || '',
                            model: {
                                provider: agent.llm?.provider || '',  // Empty = use backend LLMManager default
                                modelName: agent.llm?.model || '',     // Empty = use backend LLMManager default
                                displayName: agent.llm?.display_name || 'LLM Manager Default'
                            },
                            tools: convertTools(agent.tools),
                            maxIterations: agent.constraints?.max_steps || 5,
                            variables: [],
                            routing: { strategy: 'llm-driven', routes: [] },
                            temperature: agent.llm?.temperature || 0.7,
                            topP: 0.9,
                            maxTokens: agent.llm?.max_tokens || 4000,
                            memory: { enabled: true, type: 'short-term' },
                            adornments: []
                        }
                    };

                    activeNodes.value.push(agentNode);
                    selected.value = agentNode;
                    markWorkflowModified();
                };

                // Load registered tools from backend
                const loadRegisteredTools = async () => {
                    try {
                        console.log('üîß Loading registered tools from backend...');
                        toolsLoadError.value = null;
                        const tools = await toolAPI.listTools();
                        registeredTools.value = tools || [];
                        toolsLoaded.value = true;
                        console.log(`‚úÖ Tools loaded successfully: ${registeredTools.value.length} tools found`);

                        // Log tool details for debugging
                        registeredTools.value.forEach(tool => {
                            console.log(`  - ${tool.name} (${tool.tool_id}): ${tool.tool_type}`);
                        });
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to load tools from backend:', error.message);
                        console.log('üìù Using fallback mode (no backend tools available)');
                        toolsLoadError.value = error.message;
                        toolsLoaded.value = false;
                        registeredTools.value = [];
                    }
                };

                // Trigger tool discovery from AgentTools directory
                const triggerToolDiscovery = async () => {
                    try {
                        console.log('üîç Discovering tools from AgentTools directory...');
                        isDiscoveringTools.value = true;
                        toolDiscoveryStatus.value = 'Discovering tools...';

                        const result = await toolAPI.discoverTools();
                        toolDiscoveryStatus.value = `Discovered ${result.discovered_count || 0} tools`;
                        console.log(`‚úÖ Tool discovery complete: ${result.discovered_count} tools discovered`);
                        console.log('Discovered tools:', result.tools);

                        // Reload tools list after discovery
                        await loadRegisteredTools();

                        setTimeout(() => {
                            toolDiscoveryStatus.value = '';
                            isDiscoveringTools.value = false;
                        }, 3000);
                    } catch (error) {
                        console.error('‚ùå Tool discovery failed:', error.message);
                        toolDiscoveryStatus.value = `Discovery failed: ${error.message}`;
                        isDiscoveringTools.value = false;

                        setTimeout(() => {
                            toolDiscoveryStatus.value = '';
                        }, 5000);
                    }
                };

                // Get tool display name (for UI)
                const getToolDisplayName = (toolIdOrName) => {
                    // Check if it's a tool_id from backend
                    const tool = registeredTools.value.find(t => t.tool_id === toolIdOrName);
                    if (tool) return tool.name;

                    // Fallback: clean up the name for display
                    if (toolIdOrName.startsWith('tool_')) {
                        return toolIdOrName.substring(5).split('_').map(word =>
                            word.charAt(0).toUpperCase() + word.slice(1)
                        ).join(' ');
                    }
                    return toolIdOrName;
                };

                // =====================================================
                // SESSION MANAGEMENT (Database-backed persistent sessions)
                // =====================================================

                // Load session history from database (workflow-scoped)
                const loadSessionHistory = async () => {
                    try {
                        isLoadingSessions.value = true;
                        sessionLoadError.value = null;
                        console.log('üìã Loading session history...');

                        // Check if we have an active workflow
                        const workflowId = currentWorkflowId.value;
                        if (!workflowId) {
                            console.log('‚ÑπÔ∏è No workflow selected, clearing session history');
                            sessionHistory.value = [];
                            return;
                        }

                        // Fetch workflow-scoped chat history
                        const response = await fetch(`${API_BASE_URL}/workflows/${workflowId}/chat/history?limit=20`);
                        if (!response.ok) {
                            throw new Error(`Failed to load sessions: ${response.status}`);
                        }

                        const data = await response.json();
                        sessionHistory.value = data.sessions || data || [];
                        console.log(`‚úÖ Loaded ${sessionHistory.value.length} sessions for workflow ${workflowId}`);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not load session history:', error.message);
                        sessionLoadError.value = error.message;
                        sessionHistory.value = [];
                    } finally {
                        isLoadingSessions.value = false;
                    }
                };

                // Resume a previous chat session
                const resumeSession = async (session) => {
                    try {
                        console.log(`üìÇ Resuming session: ${session.session_id}`);

                        // Fetch full session with messages
                        const response = await fetch(`${API_BASE_URL}/sessions/${session.session_id}`);
                        if (!response.ok) {
                            throw new Error(`Failed to load session: ${response.status}`);
                        }

                        const fullSession = await response.json();

                        // Set the current session
                        chatSessionId.value = fullSession.session_id;

                        // Load messages into chat
                        chatMessages.value = (fullSession.messages || []).map(msg => ({
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '',
                            agent_id: msg.agent_id,
                            run_id: msg.run_id
                        }));

                        // If session is bound to a workflow, try to load it
                        if (fullSession.context_type === 'workflow' && fullSession.context_id) {
                            currentWorkflowId.value = fullSession.context_id;
                            workflowName.value = fullSession.title || 'Loaded Workflow';
                        }

                        // Close session history panel
                        showSessionHistory.value = false;

                        console.log(`‚úÖ Session resumed with ${chatMessages.value.length} messages`);
                    } catch (error) {
                        console.error('‚ùå Failed to resume session:', error.message);
                        alert(`Failed to resume session: ${error.message}`);
                    }
                };

                // Delete a chat session
                const deleteSession = async (sessionId, event) => {
                    if (event) event.stopPropagation();

                    if (!confirm('Are you sure you want to delete this chat session?')) {
                        return;
                    }

                    try {
                        console.log(`üóëÔ∏è Deleting session: ${sessionId}`);

                        const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}`, {
                            method: 'DELETE'
                        });

                        if (!response.ok) {
                            throw new Error(`Failed to delete session: ${response.status}`);
                        }

                        // Remove from local list
                        sessionHistory.value = sessionHistory.value.filter(s => s.session_id !== sessionId);

                        // If this was the active session, clear it
                        if (chatSessionId.value === sessionId) {
                            chatSessionId.value = null;
                            chatMessages.value = [];
                        }

                        console.log('‚úÖ Session deleted');
                    } catch (error) {
                        console.error('‚ùå Failed to delete session:', error.message);
                        alert(`Failed to delete session: ${error.message}`);
                    }
                };

                // Start a new chat session (clear current)
                const startNewSession = () => {
                    chatSessionId.value = null;
                    chatMessages.value = [];
                    showSessionHistory.value = false;
                    console.log('üÜï Started new chat session');
                };

                // Format session date for display
                const formatSessionDate = (dateStr) => {
                    if (!dateStr) return '';
                    const date = new Date(dateStr);
                    const now = new Date();
                    const diff = now - date;

                    // Less than 24 hours - show time
                    if (diff < 24 * 60 * 60 * 1000) {
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                    // Less than 7 days - show day name
                    if (diff < 7 * 24 * 60 * 60 * 1000) {
                        return date.toLocaleDateString([], { weekday: 'short' });
                    }
                    // Otherwise show date
                    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                };

                // Initialize on mount
                onMounted(async () => {
                    loadBackendAgents();
                    // Load tools immediately on mount
                    await loadRegisteredTools();
                    // Load session history
                    await loadSessionHistory();
                });

                return {
                    selected,
                    activeTab,
                    activeNodes,
                    connections,
                    showToolDropdown,
                    searchQuery,
                    zoomLevel,
                    fileInput,
                    toolConfigModal,
                    agentSearchQuery,
                    leftPaneTab,
                    promptPaneWidth,
                    isResizing,
                    workflowPrompt,
                    isGenerating,
                    generationStatus,
                    generatedWorkflows,
                    backendAgents,
                    workflowName,
                    workflowExecutionModel,
                    saveStatus,
                    workflowSaved,
                    workflowModified,
                    workflowState,
                    currentWorkflowId,
                    currentThreadId,
                    chatMessages,
                    chatInput,
                    isSendingMessage,
                    isExecuting,
                    // Execution Transparency
                    executionSteps,
                    currentRunId,
                    isExecutionInProgress,
                    // A2UI SSE
                    a2uiSurfaces,
                    a2uiActiveSteps,
                    a2uiFinalOutput,
                    a2uiTitle,
                    a2uiStreamActive,
                    a2uiActiveSurfaceId,
                    connectA2UIStream,
                    disconnectA2UIStream,
                    processA2UILine,
                    // HITL Review
                    hitlEditMode,
                    hitlEditContent,
                    hitlSubmitting,
                    submitHitlDecision,
                    formatHitlSnapshot,
                    connectExecutionWebSocket,
                    disconnectExecutionWebSocket,
                    handleExecutionEvent,
                    pollForExecutionResult,
                    executionResult,
                    showExecutionModal,
                    showInputModal,
                    workflowInput,
                    showWorkflowDialog,
                    showLoadModal,
                    draftWorkflows,
                    isLoadingDrafts,
                    manualWorkflowId,
                    nodeLibrary,
                    filteredLibrary,
                    agentTemplates,
                    filteredAgentTemplates,
                    addNode,
                    addAgentFromTemplate,
                    addBackendAgent,
                    startDrag,
                    handleCanvasMouseMove,
                    handleCanvasMouseUp,
                    handleCanvasClick,
                    selectNode,
                    deleteNode,
                    deleteConnection,
                    link,
                    getConnectionPath,
                    zoomIn,
                    zoomOut,
                    resetZoom,
                    exportWorkflow,
                    importWorkflow,
                    handleFileImport,
                    clearCanvas,
                    saveWorkflow,
                    loadWorkflowDialog,
                    loadSelectedDraft,
                    loadManualId,
                    runWorkflow,
                    addInputVariable,
                    addOutputVariable,
                    addBuiltinTool,
                    addTool,
                    removeTool,
                    openToolConfig,
                    closeToolConfig,
                    saveToolConfig,
                    getToolIcon,
                    updateModelDisplay,
                    addRoute,
                    addBranch,
                    addAgentVariable,
                    addAdornment,
                    getConnectedAgents,
                    startResize,
                    handleResize,
                    stopResize,
                    generateWorkflow,
                    sendChatMessage,
                    closeExecutionModal,
                    closeInputModal,
                    executeWithInput,
                    closeWorkflowDialog,
                    handleWorkflowChoice,
                    proceedWithModification,
                    buildWorkflowFromCanvas,
                    buildAgentsFromCanvas,
                    applyWorkflowModification,
                    loadBackendAgents,
                    // Tool System
                    registeredTools,
                    availableTools,
                    toolsLoaded,
                    toolsLoadError,
                    toolDiscoveryStatus,
                    isDiscoveringTools,
                    loadRegisteredTools,
                    triggerToolDiscovery,
                    getToolDisplayName,
                    // Session Management
                    sessionHistory,
                    isLoadingSessions,
                    sessionLoadError,
                    showSessionHistory,
                    loadSessionHistory,
                    resumeSession,
                    deleteSession,
                    startNewSession,
                    formatSessionDate
                };
            }
        }).mount('#app');
    </script>
</body>

</html>